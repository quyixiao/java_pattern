package com.pattern;

public class Doc3 {

    // 软件的可维护性与可复用性
    // 通常认为，一个易于维护的系统，就是利用率较高的系统，而一个复用性较好的系统，就是一个易于维护的系统，
    // 但是实际上，可维护性和可复用性是两个独立的目标，就像两个奔跑的兔子一样，并是总是一个方向，
    // 对于面向对象的软件设计来说，在支持可维护性的同时，提高系统的可利用性是一个核心的问题
    //一个软件业者必须认识到，软件的维护就是软件的再生，一个好的软件设计，必须能够允许新的设计要求以较为容易和平
    // 稳的方式加入到已经有的系统中去，从而使这个系统能够不断的焕发出青春
    // 一个可维护的较好的系统，就当允许维护工作能够以容易准确，安全和经济的形式进行，但是现有的软件系统设计往往不具有
    // 这样的特性
    // 个系统毫无疑问是一个优美的系统，系统的美，首先存在于设计者们的头脑中，然后存在于设计图纸之上，然后变成了一个原型
    // 系统，最后变成了一个，有血有肉的，可以交付给客户使用的成品
    // 面对着人们的抱怨，系统设计师们有一套一一模一样的辩解，用户要求的变化无常，使得系统设计无法跟上如此快速的变化，
    // 如果维护设计师与原始设计师不是同一组人员的话，就还会有很多无关的辩解出来
    // 按照这样的逻辑，一个系统的原始设计不可能预测系统的性能要求会发生什么样的变化，这就导致一个系统的设计无法与新的性能要求
    // 相容，这样一来，即便新的性能可以添加到系统中去，但是却不得不以某种破坏原始设计的意图和设计框架的方式加入进去，
    // 在很多的
    // 真正的原因，导致一个软件的设计的可维护性能较低，也就是说会随着性能要求的变化 而腐烂真正原因有四个，过于僵硬
    // 过于脆弱，利用率低，黏度过高
    // 所谓复用，就是指一个软件组成部分，可以在同一个项目的不同的地方甚至另一个项目中重复使用
    // 每当程序员发现一段代码，函数，模块所做的事情就是可以在新的模块，或者新的系统中使用的时候，他们总是发现，这些已有的代码
    // 依赖于一大堆东西，以至于很难将它们分开，最后，他们发现最好的办法就是不去碰这些已经有的东西，而是重新写自己的代码，
    // 他们可能会使用源代码剪贴的办法，以最原始的利用方式，节省一些时间
    //

    // 黏度过高
    // 有的时候，一个改变可以保存原始的设计意图和原始的设计框架方式进行，也可以破坏原始意思和框架的方式进行，第一种办法无疑
    // 第一种办法无疑对系统的未来是有利的，第二种办法是权宜之计，可以解决短期的问题，但是会牺牲长期的利益
    // 如果第二种办法比第一种办法要容易得很多的话，程序员就有可能牺牲中长期的利益，采取权宜之计，在模块中搭建一个
    // 短路桥，或者在一个通用的逻辑制造一个特例，以便解决眼前的问题
    // 一个系统的设计，如果总是使得第二种办法比第一种软件办法容易，就叫做黏度过高，一个黏度过高的系统会诱使维护他的程序员
    // 采用错误的维护方案，并惩罚采取正确的维护方案的程序员
    // 

    // 我用这一个
    // 一个好的系统应该有如下的性质，可扩展性，灵活性，可插入性，这三条性质就是一个系统设计就当达到目标，下面就是逐条讨论这三个目标
    // 可扩展性，
    // 新的性能可以很容易的加入到系统中去，就是可扩展性，这就是
    // 比如一个新的制动防滑系统应该可以在不影响汽车情况下加入到系统中去，如果加入了这个防滑系统之后，汽车就方向盘就出现了问题
    // 那么这个系统就不是很好的扩展性的系统
    // 灵活性
    // 可以允许代码修改平稳的发生，而不会波及到很多的其他的模块，这就是灵活性，
    // 复用的重要性
    // 软件的复用的好处，第一，较高的生产效率，第二，较高的软件质量，第三，恰当的复用可改善系统的可维护性
    // 一个可以重复使用的软件万分可以为将来使用节省费用，一个构件被利用的频率越高，构件初始开发的相对越少
    // 一个可复用的软件成分总是比不能复用的软件成分有更多的质量保证，如果一个复用率高的软件构件有程序缺陷的话，可以更加的快的
    // 更彻底的排除，这个软件成分必定有利于系统的可维护性
    // 更为重要的是，复用与系统的可维护性有直接的关系，这主要是由于在面向对象的系统设计复用中的概念与传统的概念有很大的不同
    // 这一点会在下面的具体的讲述
    //
    // 复用不仅仅是代码的复用，虽然代码复用确实是复用的一个初等形式
    // 代码的剪贴复用
    // 利用现代的代码编辑器，集成开发环境等，可以很容易的做到减少抄写代码的人力成本，这虽然完全没有复用好一些，但是靠剪贴
    // 源代码达到复用，仅仅是利用的最初的做法
    // 源代码的剪贴往往作为程序员自发代码利用的形式出现，在具体的实施时，仍然要冒着产生错误的风险，管理人员不可能跟踪大块
    // 代码的变异和使用
    // 由于同样或类似的源代码同时被复制多个软件成分中，当这块代码发生程序错误时，需要修改，程序员需要独立的修改每一























}
