package com.pattern;

public class Doc_2019_07_04 {
    //对可维护性的支持
    // 仍然以 PerterCoad 所给出的三个设计目标为出发点进行阐述
    // 首先，恰当的提高系统的可复用性，可以提高系统的可扩展性，允许一个具有同样的接口的新的类代替旧的类，是对抽象接口的复用，客户端面依赖
    // 于一个抽象的接口，而不是一个具体的实现类，使得这个具体的类可以被另一个具体的类所取代，而不影响到客户端内容
    // 系统的可扩展性是由开闭原则，里氏替换原则，依赖倒转原则和组合聚合利用原则所保证的。
    // 其次，恰当的提高系统的可复用性，可以提高系统的灵活性，在一个设计得当的系统中，第一个模块都相对于其他的模块独立的存在，并只保证与其他
    // 模块尽可能少的通信，这样一来，在其中某个模块发生代码修改的时候，这个修改的压力不会传递到其他的模块中。
    // 系统的灵活性是由开闭原则，迪米特原则，接口隔离原则所保证的。
    // 最后，恰当的提高系统的可复用性，可以提高系统的可插入性，在一个符合开闭原则的系统中，抽象则封装了与商业逻辑相关的重要行为，这些行动
    // 具体的实现由实现层给出，当一个实现类不再满足需要，需要另一个实现类取代的时候，系统的设计可以保证旧的类可以被拔出，新的类可以被插入
    // 系统的可插入性是由开闭原则，里氏替换原则，组合，聚合复用原则以及依赖倒转原则保证。
    // 这就是说，本书将要介绍的这些原则在提高一个系统的可维护性的同时，提高这个系统的可复用性的指导原则，按照这个原则进行系统设计，就可以
    // 抓到同时奔跑的兔子。
    // 设计原则有哪些
    // 本书在后面将要介绍设计原则如下
    // 开闭原则，
    // 里氏替换原则
    // 依赖倒转原则
    // 接口隔离原则
    // 组合聚合利用原则
    // 迪米特法则
    // 这些设计原则首先都是复用的原则，遵循这些原则可以有效的提高系统的可复用性，同时提高系统的的可维护性。
    // 学习设计模式对复用性与可维护性的帮助。
    // 凡是有理论的地方，就有如何给当地将理论应用到实践中去的问题，设计模式是对学习 OO 设计原则的具体的指导。
    // 本书将要介绍的设计模式可以划分成创建模式，结构模式和行为模式三大类别，专门讲解的设计模式有26个，在讲解过程中所涉及到的模式就更加的多了
    // 设计模式本身并不能保证一个系统的可复用性和可维护性，但是通过学习这些设计模式工的思想可以有效的保证设计师的设计风格，设计水平，并促进
    // 与同行之间的沟通，从而帮助设计师提高系统的利用性和可维护性
    // 老子云，善为士者不武，如果士，就像软件系统的设计师，武，就是软件系统的大规模的修改，那么老子说的就是，老子说的所谓的不武，但是软件
    // 设计中的复用
    // 老子还说，天下有道，却走马以粪，天下无道，戎马生于效，也就是说，天下太平，好的跑马却在田间耕作，当天下不太平时，战马在战场上生下小驹。
    // 这相当于说，当一个软件系统是一个复用有道，易于维护的系统时，将新的性能加入到系统中去，或者对于一个已有的性能进行修改是不困难的事情，
    // 因此，代码高手就无法发挥作用，而当一个软件是一个设计低劣，可维护性差的系统时，代码高手就必须连续作战，才能将新的性能加入到系统中去
    // 或者对于一个已有的性能进行修改
    // 开闭原则讲的是，一个软件实体应当对扩展开放，对修改关闭，这一个原则早由英文原文是
    // 这个原则说的就是，在设计一个模块的时候，应当使用这个模块可以在不被修改的前提下被扩展，换言之，应当在可以不必修改源代码的情况下，改变
    // 这种模块的行为
    // 这话听上去好像是矛盾的，但是实际上配将在后面给个几个面向对象的设计原则和设计模式中很具体的如何在设计上做到这一点
    // 所有的软件系统都有一个共同的性质，即它们的需求会随着时间的变化而变化，在软件系统面临新的需求时，系统的设计必须是稳定的，满足开闭
    // 原则系统会给系统带来无可比似的优越性。
    //  通过扩展已有的软件系统，可以提供新的行为，以满足对软件的新的需求，使变化中的软件系统有一定适应性和灵活性。
    //  已有的软件模块，特别是最重要的抽象层模块不能再修改，这就使变化中的软件系统有一定的稳定性和延续性。
    // 具有这两个优点的软件系统是一个高层次上实现复用的系统，也是一个易于维护的系统。
    // 玉帝招安美猴王。
    // 招安之法的关键便是不允许更改现有天庭秩序，但是允许将妖猴纳入到现有的秩序中，从而扩展了这一次序，用面向对象的语言来讲，不允许更改
    // 的是系统的抽象层，而允许修改的是系统的实现层。
    // 太玄 论 固革
    // 西汉杨雄的太玄 一书中说，知固而不知革，物失其则，知革而不知固，物失其均，
    // 一个系统对修改关闭，就是太玄所说的固，而一个系统对扩展开放，就是太玄所说的革，如果一个系统不可扩展，就会失去他的使用价值，而一个
    // 系统动辄需要修改，便会失去他的重心
    // 抽象化是关键
    // 解决问题是关键在于抽象，在像 Java 语言这样的面向对象的编程语言里，可以给系统定义一个一劳永逸的，不再更改的抽象设计，此设计允许有
    // 无穷无尽的行为在实现层被实现，在 Java 的语言里，可以给出一个或多个抽象 Java 类或者 java接口，规定出所有的具体类必须提供的方法
    // 的特征作为系统设计的抽象层，这个抽象层预见的所有的可能扩展的，因此，在任何情况下都不会改变，这就使得系统的抽象层不需要修改
    // 从而满足对开闭原则的第二条，对修改关闭
    // 同时，由于抽象层导出的一个或多个新的具体的类可以改变的行为，因此系统的设计对扩展是开放的，这就满足了开闭原则的第一条
    // 对可变性的封装原则
    // 开闭原则如果从另一个角度来讲，就是所谓的对可变性的封装原则，对可变性的封装原则，讲的就是找到一个系统的可变的因素，将之封装出来
    // 在中说，考虑到你的设计中可能会发生变化，与通常的焦点放到什么会导致设计的改变的思考方式正好相反，这一思路考虑到不是什么导致改变
    // 而是考虑到你允许什么发生变化而不让这一变化导致重新设计
    // 将这一思想用到了一句话总结为找到一个系统的可变因素，将它封装起来，并将它命名为对可变性的封装原则
    // 对可变性的封装原则就意味着这两点
    // 一种可变性不应当散落在代码的很多的角落里，而应当被封装到一个对象里面，同一种可变性的不同表象里，读者可以在设计模式中看到继承关系
    // 继承就当被看做是封装变化的方法，而不就当被座谈是从表般对象生成特殊对象的方法
    // 一种可变性不应当与另一种可变性混合在一起，如果读者留心书上所研究的这些设计模式的类图的话，就会发现所有的类图的继承结构一般不会
    // 超过两层，不然就意味着将这两中不同的可变性混合在一起
    // 显然，对可变性的封装原则，从工程的角度上讲解了如何实现开闭原则，如果能够将可变性封装原则，作为总的设计原则的话，那么就按照这个原则
    // 进行系统设计
    // 做到开闭原则不是一件容易的的工作，但是也是很多的规律可循的，这些规律也同样的设计原则的身份，显然，对可变性的封装原则，从工程的角度上
    // 讲解了如何实现开闭原则，如果能够将对可变性封装原则，作为总的设计原则的话，那么按照这个原则进行系统设计，遵守开闭原则
    // 尽管在很多的情况下，无法百分之百地做到了开闭原则，但是如果向这个方向上的努力能够得到部分的成功，也可以显著的改善一个系统的结构,
    // 与其他设计原则的关系
    // 里氏替换原则中说，任何基类可以出现的地方，子类一定可以出现
    // 里氏替换原则是对开闭原则的补充，正如前面所谈到的实现开闭原则关键步骤是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏
    // 替换原则是对抽象化具体的步骤的规范
    // 一般而言，违反了里氏替换原则，也就是违背了开闭原则，反过来并不一定成立
    // 依赖倒转原则
    // 依赖倒转原则讲的就是，要依赖于抽象，但是不要依赖于具体的实现
    // 看上去依赖倒转原则与开闭原则有很大的相似之处，实际上，它们之间的关系是目标和手段之间的关系，开闭原则有很大的，开闭原则的目标，而达到
    // 这一目标的第一段是依赖倒转原则，换言之，
    // 要想实现开闭原则，就就当坚持依赖倒转原则，违反了依赖倒转原则，就不可能达到开闭原则的要求
    // 依赖倒转原则
    // 依赖倒转原则讲的是，要依赖于抽象，不要依赖于实现
    // 看上去，依赖原则与开闭原则有很大的相似之处，实际上，它们之间关系是目标和手段之间的关系，开闭原则是目标，而达到这一目标的手段是依赖
    // 原则，换言之，要想实现开闭原则，就应当是是支持依赖原则，违反了依赖倒转原则，就不能实现开闭原则的要求
    // 合成聚合复用原则
    // 合成/聚合的复用原则讲的就是，要尽量的使用合成聚合，而不是继承关系达到复用的目的，
    // 显然，合成/聚合复用原则是与里氏替换原则相辅相成的，两者又都是对实现开闭原则的具体步骤规范，前者要求设计师首先考虑合成聚合关系，
    // 后者要求使用继承关系时，必须确定这个关系符合一定的条件
    // 遵守合成聚合复用原则是实现开闭原则的必要条件，违反这一原则就无法使用系统实现开闭原则这一目标

    // 迪米特法则
    // 迪类物法则讲的就是，一个软件实体应当与尽可能少的其他的实体发生相互作用
    // 当一个系统面临功能扩展的时候，其中会有一些模块，它们需要修改压力比其他的一些模块要大，最后的结果可能是这些模块需要修改或者不需要修改
    // 但是无论是哪一种情况，如果这些模块是相对孤立的，那么它们就不会将修改的压力传递给其他的模块
    // 这就是说，一个遵守迪米特原则设计出来的系统在功能需要扩展时，会相对更加容易一些，会相对做到对修改关闭，也就是说，迪为特法则，是一
    // 条通向开闭原则的道路
    // 接口的隔离原则讲的是应当为客户端提供尽可能小的单独接口，而不要为提供大的总接口
    // 显然，接口的隔离原则与广义的迪米特法则是一个对软件实体与其他的软件实体通信的限制，广义的迪米特法则要求尽可能限制通信的深度，接口
    // 隔离原则所限制的通信的宽度，也就是说，通信尽可能的窄，
    // 显然，遵循接口的隔离原则与迪米特法则，会使一个软件系统在功能扩展的过程中，不会将修改的压力传递到其他的对象
    // 策略模式对开闭原则的支持
    // 策略模式讲的是，如果有一组算法，那么就将每一个算法封装起来，使得它们可以互换，显然，策略模式就是可以从对可变性的封装原则出发，
    // 达到一个开闭原则的一个范例
    // 在本书后面的策略模式，一章讨论了图书的销售的折扣计算问题，显然，根据描述，折扣是根据以下的第几个算法中的一个进行的
    // 算法一：对有些图书没有折扣，折扣算法对象返回0作为折扣值
    // 算法二，对有些图书提供的一个固定量的值为1元的折扣
    // 算法三：对有些图书提供一个百分提供一个百分比，比如一本书价格为20元，折扣百分比为7%,那么折扣值就是1.4元
    // 在采用策略模式之前，设计师必须从开闭原则出发，考察这个图书销售系统是否可能在将来的引入新的算法，如果有可能，那么就将当前所有的折扣
    // 算法封装起来，因为它们是可变的因素，系统必须能够在新算法出现时，很方便的将新的算法插入到已有的系统中，而不必修改已有的系统算法
    // 使用策略模式描述的话， 这些不同的算法都是用不同的具体的策略角色，从算法到算法三分别可以用 NodiscountStragegy 对象，FlatRateStratgy
    // 对象和 PercentageStrategy 对象描述
    // 为了使这些算法成为即插即用的对象，必须使用这些算法能够相互替换，而做到这一点是非常的关键的，就是给这些对象定义出相同的接口，也就是需要
    // 一个抽象的策略角色作为这些对象所组成等级结构的超类型，在现有的讨论图销售的折扣计算系统中，这引进抽象的策略角色由一个 java 抽象类
    // DisCountStrategy
    // 在其他的设计模式中体现
    // 对可变性原则的封装，实际上是设计模式的主题，换言之，所有的设计模式都是对不同的可变性封装，从而使系统在不同的角度上达到开闭原则要求
    // 下面就是给出的几个例子
    // 开闭原则要求系统允许产品加入到新的系统中，对无需对现有的代码进行修改，在简单的工厂模式中，这对于产品的消费角色是成立的，而对于工厂角色是不
    // 成立的，如下图所示，每次新增加一个新的产品，都是需要修改工厂角色，但是产品的消费者可以避免进行修改
    //

    // 工厂方法模式
    // 在工厂方法模式中，具体的工厂类有共同的接口，它们生产出现很多牌一个等级结构中的产品对象，使用这个设计的系统可以允许向系统加入新的产品类型
    // 而不必修改已有代码，只需要加入一个相应的具体的工厂类就可以了，工厂方法模式
    // 换言之，对于增加新的产品类型而言，这个系统完全支持开闭原则
    //


    // 抽象工厂模式
    // 抽象工厂模式封装了产品对象的定州的可变性，从而一方面可以使得系统动态的决定将哪一个产品实例化，另一方面可以在新的产品对象引进而
    // 已有的系统不必要的修改，产品对象家族发生变化时，这个设计可以维持系统的开闭性，抽象工厂模式的简略图如下
    // 建造模式封装了一个内部结构的产品对象的过程，因此，这样的系统是向产品内部表象的改变开始的，建造模式的
    //


    // 桥梁模式
    // 桥梁模式是对可变性封装原则的极好的例子，在桥梁模式中，具体的实现类代表着不同的实现逻辑，但是所有的具体的实现类又有共同的接口，新的
    // 实现逻辑可以通过创建新的具体的实现类加入到系统里面，桥梁模式的简略如下图

    // 门面模式
    // 假设一个系统开始的时候与某个子系统耦合在一起，后来又不得不换成另一个子系统，那么门面模式便可以发挥门面模式的两种作用，将新的子系统
    // 仍然合在一起，这样一来，使用门面模式便可以改变子系统内部的功而不会影响到客户端，门面模式的简略图如下图所示
    //

    // 调停者模式
    // 调停模式使用一个调停者对象协调和个对象的相互作用，这些同事对象之间不再发生直接的相互作用，调停者模式的简略图

    // 这样的，一旦有新的同事加入到系统中来的时候，这些已有的同事对象都不会受到任何影响，但是调停者对象本身却要修改，调停者模式以一种
    // 不完美的方式支持开闭原则
    //
    // 访问者模式使得在节点的加入新的方法变得很容易，仅仅需要在一个新的访问者类中加入此方法就可以了，但是访问者模式不能很好的处理新的
    // 节点加入的情况，访问者模式提供倾斜的可扩展性的设计，方法的集合可扩展性和类的集合可扩展性。
    //
    // 迭代子模式将访问聚集元素的逻辑封装起来，并且使它独立于聚集对象的封装，这就提供了聚集存储逻辑与迭代逻辑的独立演变的空间。
    // 使系统可以在无需修改消费迭代子的客户端的情况下，对聚集对象的内部结构进行功能的扩展，迭代子模式的简略类图如下
    //

    // 当读者学习设计模式的时候，要学会问一个问题，这个设计模式可以对什么样的变换开放，以及它做一些所付出的个代价是什么，通过这样的思考
    // 可以更加透彻的解决这种对开闭原则的支持程度，以及对设计模式本身的一种做法。

    // 一个重构的做法讨论
    // 将条件转移语句改写成多态性，一个




}
