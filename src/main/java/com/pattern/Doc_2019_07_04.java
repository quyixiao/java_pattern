package com.pattern;

public class Doc_2019_07_04 {
    //对可维护性的支持
    // 仍然以 PerterCoad 所给出的三个设计目标为出发点进行阐述
    // 首先，恰当的提高系统的可复用性，可以提高系统的可扩展性，允许一个具有同样的接口的新的类代替旧的类，是对抽象接口的复用，客户端面依赖
    // 于一个抽象的接口，而不是一个具体的实现类，使得这个具体的类可以被另一个具体的类所取代，而不影响到客户端内容
    // 系统的可扩展性是由开闭原则，里氏替换原则，依赖倒转原则和组合聚合利用原则所保证的。
    // 其次，恰当的提高系统的可复用性，可以提高系统的灵活性，在一个设计得当的系统中，第一个模块都相对于其他的模块独立的存在，并只保证与其他
    // 模块尽可能少的通信，这样一来，在其中某个模块发生代码修改的时候，这个修改的压力不会传递到其他的模块中。
    // 系统的灵活性是由开闭原则，迪米特原则，接口隔离原则所保证的。
    // 最后，恰当的提高系统的可复用性，可以提高系统的可插入性，在一个符合开闭原则的系统中，抽象则封装了与商业逻辑相关的重要行为，这些行动
    // 具体的实现由实现层给出，当一个实现类不再满足需要，需要另一个实现类取代的时候，系统的设计可以保证旧的类可以被拔出，新的类可以被插入
    // 系统的可插入性是由开闭原则，里氏替换原则，组合，聚合复用原则以及依赖倒转原则保证。
    // 这就是说，本书将要介绍的这些原则在提高一个系统的可维护性的同时，提高这个系统的可复用性的指导原则，按照这个原则进行系统设计，就可以
    // 抓到同时奔跑的兔子。
    // 设计原则有哪些
    // 本书在后面将要介绍设计原则如下
    // 开闭原则，
    // 里氏替换原则
    // 依赖倒转原则
    // 接口隔离原则
    // 组合聚合利用原则
    // 迪米特法则
    // 这些设计原则首先都是复用的原则，遵循这些原则可以有效的提高系统的可复用性，同时提高系统的的可维护性。
    // 学习设计模式对复用性与可维护性的帮助。
    // 凡是有理论的地方，就有如何给当地将理论应用到实践中去的问题，设计模式是对学习 OO 设计原则的具体的指导。
    // 本书将要介绍的设计模式可以划分成创建模式，结构模式和行为模式三大类别，专门讲解的设计模式有26个，在讲解过程中所涉及到的模式就更加的多了
    // 设计模式本身并不能保证一个系统的可复用性和可维护性，但是通过学习这些设计模式工的思想可以有效的保证设计师的设计风格，设计水平，并促进
    // 与同行之间的沟通，从而帮助设计师提高系统的利用性和可维护性
    // 老子云，善为士者不武，如果士，就像软件系统的设计师，武，就是软件系统的大规模的修改，那么老子说的就是，老子说的所谓的不武，但是软件
    // 设计中的复用
    // 老子还说，天下有道，却走马以粪，天下无道，戎马生于效，也就是说，天下太平，好的跑马却在田间耕作，当天下不太平时，战马在战场上生下小驹。
    // 这相当于说，当一个软件系统是一个复用有道，易于维护的系统时，将新的性能加入到系统中去，或者对于一个已有的性能进行修改是不困难的事情，
    // 因此，代码高手就无法发挥作用，而当一个软件是一个设计低劣，可维护性差的系统时，代码高手就必须连续作战，才能将新的性能加入到系统中去
    // 或者对于一个已有的性能进行修改
    // 开闭原则讲的是，一个软件实体应当对扩展开放，对修改关闭，这一个原则早由英文原文是
    // 这个原则说的就是，在设计一个模块的时候，应当使用这个模块可以在不被修改的前提下被扩展，换言之，应当在可以不必修改源代码的情况下，改变
    // 这种模块的行为
    // 这话听上去好像是矛盾的，但是实际上配将在后面给个几个面向对象的设计原则和设计模式中很具体的如何在设计上做到这一点
    // 所有的软件系统都有一个共同的性质，即它们的需求会随着时间的变化而变化，在软件系统面临新的需求时，系统的设计必须是稳定的，满足开闭
    // 原则系统会给系统带来无可比似的优越性。
    //  通过扩展已有的软件系统，可以提供新的行为，以满足对软件的新的需求，使变化中的软件系统有一定适应性和灵活性。
    //  已有的软件模块，特别是最重要的抽象层模块不能再修改，这就使变化中的软件系统有一定的稳定性和延续性。
    // 具有这两个优点的软件系统是一个高层次上实现复用的系统，也是一个易于维护的系统。
    // 玉帝招安美猴王。
    // 招安之法的关键便是不允许更改现有天庭秩序，但是允许将妖猴纳入到现有的秩序中，从而扩展了这一次序，用面向对象的语言来讲，不允许更改
    // 的是系统的抽象层，而允许修改的是系统的实现层。
    // 太玄 论 固革
    // 西汉杨雄的太玄 一书中说，知固而不知革，物失其则，知革而不知固，物失其均，
    // 一个系统对修改关闭，就是太玄所说的固，而一个系统对扩展开放，就是太玄所说的革，如果一个系统不可扩展，就会失去他的使用价值，而一个
    // 系统动辄需要修改，便会失去他的重心
    // 抽象化是关键
    // 解决问题是关键在于抽象，在像 Java 语言这样的面向对象的编程语言里，可以给系统定义一个一劳永逸的，不再更改的抽象设计，此设计允许有
    // 无穷无尽的行为在实现层被实现，在 Java 的语言里，可以给出一个或多个抽象 Java 类或者 java接口，规定出所有的具体类必须提供的方法
    // 的特征作为系统设计的抽象层，这个抽象层预见的所有的可能扩展的，因此，在任何情况下都不会改变，这就使得系统的抽象层不需要修改
    // 从而满足对开闭原则的第二条，对修改关闭
    // 同时，由于抽象层导出的一个或多个新的具体的类可以改变的行为，因此系统的设计对扩展是开放的，这就满足了开闭原则的第一条
    // 对可变性的封装原则
    // 开闭原则如果从另一个角度来讲，就是所谓的对可变性的封装原则，对可变性的封装原则，讲的就是找到一个系统的可变的因素，将之封装出来
    // 在中说，考虑到你的设计中可能会发生变化，与通常的焦点放到什么会导致设计的改变的思考方式正好相反，这一思路考虑到不是什么导致改变
    // 而是考虑到你允许什么发生变化而不让这一变化导致重新设计
    // 将这一思想用到了一句话总结为找到一个系统的可变因素，将它封装起来，并将它命名为对可变性的封装原则
    // 对可变性的封装原则就意味着这两点
    // 一种可变性不应当散落在代码的很多的角落里，而应当被封装到一个对象里面，同一种可变性的不同表象里，读者可以在设计模式中看到继承关系
    // 继承就当被看做是封装变化的方法，而不就当被座谈是从表般对象生成特殊对象的方法
    // 一种可变性不应当与另一种可变性混合在一起，如果读者留心书上所研究的这些设计模式的类图的话，就会发现所有的类图的继承结构一般不会
    // 超过两层，不然就意味着将这两中不同的可变性混合在一起
    // 显然，对可变性的封装原则，从工程的角度上讲解了如何实现开闭原则，如果能够将可变性封装原则，作为总的设计原则的话，那么就按照这个原则
    // 进行系统设计
    // 做到开闭原则不是一件容易的的工作，但是也是很多的规律可循的，这些规律也同样的设计原则的身份，显然，对可变性的封装原则，从工程的角度上
    // 讲解了如何实现开闭原则，如果能够将对可变性封装原则，作为总的设计原则的话，那么按照这个原则进行系统设计，遵守开闭原则
    // 尽管在很多的情况下，无法百分之百地做到了开闭原则，但是如果向这个方向上的努力能够得到部分的成功，也可以显著的改善一个系统的结构,
    // 与其他设计原则的关系
    // 里氏替换原则中说，任何基类可以出现的地方，子类一定可以出现
    // 里氏替换原则是对开闭原则的补充，正如前面所谈到的实现开闭原则关键步骤是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏
    // 替换原则是对抽象化具体的步骤的规范
    // 一般而言，违反了里氏替换原则，也就是违背了开闭原则，反过来并不一定成立
    // 依赖倒转原则
    // 依赖倒转原则讲的就是，要依赖于抽象，但是不要依赖于具体的实现
    // 看上去依赖倒转原则与开闭原则有很大的相似之处，实际上，它们之间的关系是目标和手段之间的关系，开闭原则有很大的，开闭原则的目标，而达到
    // 这一目标的第一段是依赖倒转原则，换言之，
    // 要想实现开闭原则，就就当坚持依赖倒转原则，违反了依赖倒转原则，就不可能达到开闭原则的要求
    // 依赖倒转原则
    // 依赖倒转原则讲的是，要依赖于抽象，不要依赖于实现
    // 看上去，依赖原则与开闭原则有很大的相似之处，实际上，它们之间关系是目标和手段之间的关系，开闭原则是目标，而达到这一目标的手段是依赖
    // 原则，换言之，要想实现开闭原则，就应当是是支持依赖原则，违反了依赖倒转原则，就不能实现开闭原则的要求
    // 合成聚合复用原则
    // 合成/聚合的复用原则讲的就是，要尽量的使用合成聚合，而不是继承关系达到复用的目的，
    // 显然，合成/聚合复用原则是与里氏替换原则相辅相成的，两者又都是对实现开闭原则的具体步骤规范，前者要求设计师首先考虑合成聚合关系，
    // 后者要求使用继承关系时，必须确定这个关系符合一定的条件
    // 遵守合成聚合复用原则是实现开闭原则的必要条件，违反这一原则就无法使用系统实现开闭原则这一目标

    // 迪米特法则
    // 迪类物法则讲的就是，一个软件实体应当与尽可能少的其他的实体发生相互作用


}
