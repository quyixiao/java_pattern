package com.pattern;

public class Doc_2019_07_12 {
    // 工厂模式的几种形态
    // 工厂模式专门负责将大量的共同接口的类实例化，工厂模式可以动态的决定将哪一个类实例化，不必事先知道每次要实例化的哪一个类.工厂模式
    // 以下的几种形态
    // 简单的工厂模式: 又称为多态性的工厂模式或虚拟的构造子模式
    // 抽象工厂模式：又称工具箱模式
    // 简单的工厂模式：又称为静态工厂模式，是不同的工厂方法模式的一个特殊实现，在其他的文献中，简单的工厂模式往往作为普通的工厂一个特例
    // 讨论
    // 在java语言中，通常的工厂方法模式不能通过设计功能的退化给出静态工厂方法模式，因为一个方法是不是静态的，对于java语言来说是一个很大的
    // 必须在一开始的时候就加以讨论，这就是这本书将简单的工厂单独的提出来讨论的原因，学习简单的工厂模式对学习工厂方法模式的一个很好的
    // 准备，也是对学习其他的模式，特别是单例模式和多例模式的一个很好的准备，这就是本书首先讲解一个模式的另一个原因
    // 角色也结构
    // 角色与结构
    // 简单的工厂模式就是由一个工厂类根据传入的参量决定创建出哪一种产品类型，下面以一
    // 从上图可以看出，工厂模式涉及到工厂角色，抽象产品角色以及具体的产品角色等三个角色
    // 工厂类的角色：担任这个角色的是工厂方法模式核心，含有与应用紧密相关的商业逻辑，工厂类在客户端直接调用下创建产品对象，它往往由一个
    // 具体的类java 类实现
    // 抽象和产品角色:担任这个角色的类是由工厂方法模式所创建的对象，它往往是由一个具体的java类实现
    // 抽象产品的角色，担任这个角色的类是由工厂模式所创建的对的父类，或它们共同拥有的接口，抽象产品角色可以用这个java接口或者java抽象实现
    // 使用java接口或者java抽象类
    // 如果模式所产生的具体的产品类彼此之间没有共同的商业逻辑，那么抽象产品的角色可以由一个java接口来扮演，相反，如果这些具体的产品类彼此之间
    // 确实有共同的商业逻辑，那么这些公有的逻辑就应当移到抽象的角色里，这就意味着抽象角色应当由一个抽象类扮演，在一个类的等级结构里，共同的
    // 代码应当尽量向上移动，以达到共享目的
    // 每个工厂类可以有一个多于一个工厂的方法，分别负责创建不同的产品对象，比如java.text.DateFormat类是其子类的工厂类，而dateformate类就
    // 提供了静态工厂方法
    // 抽象产品的角色的省略
    // 如果系统仅有一个具体的产品的角色的话，那么就可以省略抽象产品的角色，
    // 每个工厂类可以有多于一个工厂的方法，分别负责创建不同的产品对象，比如，java.text.DateFormat类是其子类的工厂类，而DateFormate类
    // 提供了多个静态方法，请参见本章的后面的说以讲解
    // 抽象产品角色的省略
    // 如果系统仅有一个具体的产品角色的话，使用java接口或者java抽象类
    // 如果模式所产生的具体的和产品类彼此之间没有共同的
    // 显然，三个原本独立的角色，工厂角色，抽象产品以及具体的产品角色都已经合并成一个类，这个类自己创建自己的实例，如下代码所示
    // 这种退化的简单的工厂模式与单例模式以及多例模式有相似之处，但是并不等于单例或才多例模式，关于这一点讨论请参考本章后面的叙述
    // 产品对象的循环使用和登记方式的工厂方法
    // 由于简单的工厂模式是一个非常基本的设计模式，因此它会在较为复杂的设计模式中出现，在本章前面所给出的要注意性例子中，工厂方法总是简单的调用
    // 产品的类型的构造以创建出一个新的产品实例，然后将这个实例提供给客户端，而实际情形中，工厂方法所做的事情可以相当的复杂
    // 本书所讨论的所有的设计模式中，单例模式也多例模式是建立在简单的工厂模式的基础之间的
    // 而且它们都要求工厂方法具有特殊的逻辑，以便能循环的使用和产品的实例
    // 在很多的情况下，产品对象可以循环使用，工厂方法可以循环的使用已经创建出来的对象，而不是每一次都创建新的产品对象，工厂方法可以通过登记它
    // 所创建的和产品对象来达到循环使用产品的对象的目的
    // 如果工厂方法总是循环的使用同一个产品对象，那么这个工厂对象可以使用一个属性来存储这个产品对象，每一次客户端调用工厂方法时，向外界提供一个
    // 惟一的单例类实例
    // 如果工厂方法永远的循环的使用固定数目的一些产品对象的，而且这些产品对象的数目并不大的话，可以使用一些私有的属性存储这些产品对象的引用
    // 比如使一个永远只提供一个产品对象的工厂对象可以使用一个静态变量存储对这个产品对象的引用
    // 相反，如果工厂方法使用的数目不确定的话，或者数目较大的一些产品对象的话，使用属性变量储存这些产品对象的引用就不方便了，这个时候
    // 就应当使用聚集对象存储对产品对象的引用
    // 不管使用哪一种方法，工厂方法都可以做到循环的使用它所创建的产品对象，循环的逻辑可能是基于这些产品类的内部的状态的，比如某一种状态的
    // 产品对象创建一个，让所有的需要处于这一状态上的产品对象的客户端共享这一个实例
    // 简单的工厂模式与其他的模式的关系
    // 单例模式
    // 单例模式使用了简单的工厂模式，单例类具有一个静态工厂方法提供自身的实例，一个抽象产品类同时是子类的工厂
    // 但是单例模式并不是简单的工厂模式的退化的情形，单例模式要求单例类的构造子是私有的，从而客户端不能直接将之实例化，而必须 通过个这
    // 静态工厂方法将之实例化，而且单例类自身是自己的工厂角色，单例类自己负责创建自身的实例
    // 单例类使用一个静态属性存储自己的唯一实例，工厂方法永远仅提供这一个实例
    // 多例模式
    // 多例模式是对单例模式的推广，多例模式与单例模式的共同之处在于它们都禁止也外界直接将之实例化，同时通过静态工厂方法向外界提供循环使用
    // 的自身实例，它们的不同在于单例模式仅有一个实例，而多例模式有多个实例
    // 多例模式往往具有一个聚集的属性，通过向这个聚集的属性登记已经创建过的实例达到循环使用实例的目的，一般而言，一个典型的多例类具有某种
    // 内部状态，这个内部状态可以用来区分和个实例，而对应的每一个内部的状态，都只有一个实例存在
    // 根据外界传入的柔肠寸断 ，工厂方法可以查询自己登记的聚集，如果一个具体的这个状态的实例已经存在，就直接将这个实例提供给外界，反之
    // 就首先创建一个新的满足要求的实例
    // 备忘录模式
    // 单例模式和多例模式使用一个属性或者聚集属性来登记所有的创建的产品对象，以便可以通过查询这个属性或者聚集属性找到并共享已经创建的产品的
    // 对象，这就是备忘录模式应用，备忘录模式的简略类图如下图所示
    //




























}
