package com.pattern;

public class Doc_2019_07_12 {
    // 工厂模式的几种形态
    // 工厂模式专门负责将大量的共同接口的类实例化，工厂模式可以动态的决定将哪一个类实例化，不必事先知道每次要实例化的哪一个类.工厂模式
    // 以下的几种形态
    // 简单的工厂模式: 又称为多态性的工厂模式或虚拟的构造子模式
    // 抽象工厂模式：又称工具箱模式
    // 简单的工厂模式：又称为静态工厂模式，是不同的工厂方法模式的一个特殊实现，在其他的文献中，简单的工厂模式往往作为普通的工厂一个特例
    // 讨论
    // 在java语言中，通常的工厂方法模式不能通过设计功能的退化给出静态工厂方法模式，因为一个方法是不是静态的，对于java语言来说是一个很大的
    // 必须在一开始的时候就加以讨论，这就是这本书将简单的工厂单独的提出来讨论的原因，学习简单的工厂模式对学习工厂方法模式的一个很好的
    // 准备，也是对学习其他的模式，特别是单例模式和多例模式的一个很好的准备，这就是本书首先讲解一个模式的另一个原因
    // 角色也结构
    // 角色与结构
    // 简单的工厂模式就是由一个工厂类根据传入的参量决定创建出哪一种产品类型，下面以一
    // 从上图可以看出，工厂模式涉及到工厂角色，抽象产品角色以及具体的产品角色等三个角色
    // 工厂类的角色：担任这个角色的是工厂方法模式核心，含有与应用紧密相关的商业逻辑，工厂类在客户端直接调用下创建产品对象，它往往由一个
    // 具体的类java 类实现
    // 抽象和产品角色:担任这个角色的类是由工厂方法模式所创建的对象，它往往是由一个具体的java类实现
    // 抽象产品的角色，担任这个角色的类是由工厂模式所创建的对的父类，或它们共同拥有的接口，抽象产品角色可以用这个java接口或者java抽象实现
    // 使用java接口或者java抽象类
    // 如果模式所产生的具体的产品类彼此之间没有共同的商业逻辑，那么抽象产品的角色可以由一个java接口来扮演，相反，如果这些具体的产品类彼此之间
    // 确实有共同的商业逻辑，那么这些公有的逻辑就应当移到抽象的角色里，这就意味着抽象角色应当由一个抽象类扮演，在一个类的等级结构里，共同的
    // 代码应当尽量向上移动，以达到共享目的
    // 每个工厂类可以有一个多于一个工厂的方法，分别负责创建不同的产品对象，比如java.text.DateFormat类是其子类的工厂类，而dateformate类就
    // 提供了静态工厂方法
    // 抽象产品的角色的省略
    // 如果系统仅有一个具体的产品的角色的话，那么就可以省略抽象产品的角色，




























}
