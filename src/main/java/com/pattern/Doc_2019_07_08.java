package com.pattern;

public class Doc_2019_07_08 {
    // 如果有一组算法，那么就将每一组算法封装起来，使得它们可以互换
    // 从上面的代码片断可以看出，客户端依赖于基类类型，而变量的真实类型则是具体的策略类，这是具体的策略角色可以 即插即用的 关键
    // 合成模式
    // 合成模式，通过使用树结构的描述的整体与部分的关系，从而可以将单纯的元素与复合元素的同行看待，由于单纯的元素和复合的元素都是抽象元素的
    // 子类，因此两者可都可以替代抽象元素出现的任何地方，合成模式的简略图如下图所示
    // 代理模式给对象提供了一个代理对象，并由代理对控制对原对象的引用，代理模式能够成立的关键，就在于代理模式与真实的模式都是抽象角色子类
    // 客户端知道抽象主题，而代理主题可以替代抽象主题出现在任何需要的地方，而将真实主题隐藏幕后，
    // 里氏替换原则讲的是基类与子类之间的关系，只有当这种关系存在时，里氏替换关系才存在，反之则不存在，如果有两个具体的类 A 和 B 之间的关系
    // 违反了里氏替换原则设计，根据具体的情况，下面两种情况中选择一种
    // 这个，只要 width 或 height 被赋值，那么 width和 height 会被同时赋值，从而是使长方形的长和宽总是相等的，
    // 代码重构
    // 根据墨子在两千多年
    // 正如本书在专题抽象类一章中所指出的，应当尽量众抽象类继承，而不从具体的类继承，Quadrangle 接口相当于抽象类，使用这个抽象角色解决了
    // 两个具体的类和 Suqare 具体的继承关系的问题
    // 依赖倒转原则
    // 实现开闭原则关键是抽象化，并且从抽象化导出具体的实现，如果 说 开闭 原则是面向对象的设计的目标的话，依赖倒转原则就是这个面向对象的设计的主要
    // 机制
    // 依赖倒转原则讲的是要依赖于抽象，不要依赖于具体的
    // 为什么要使用倒转，一词，依赖倒转的意义是
    // 简单的来说，传统的过程性系统的设计办法倾向于使用高层次的模块依赖于低层次的模块依赖，抽象层依赖于具体的层，倒转原则就是要把这个
    // 借误的依赖关系倒转过来，这就是依赖倒转原则
    // 抽象层次依赖于具体的层次的含义是什么，抽象层次包含的是应用系统的商务逻辑和宏观的，对整个系统来说中重要的战略性决定，是必然的，
    // 的体现，而具体的层次则含有一些次要的与实现有关的算法和逻辑，以及战术性的的决定的，带有相当大的偶然性的选择，具体的层次代码与实现
    // 有关的算法变化立即而抽象层次依赖于具体的的层次，使许多的具体的层次细节的算法变化立即影响到了抽象层次的宏观的商务逻辑，导致微观的决定
    // 层次，导致微观的决定宏观，战术决定战战略，偶然决定必然，下图，
    // 依赖倒转原则是 COM,CORBA，JaVABean ，以及 EJB 等构建设计模型背后的基本的原则
    // 复用与可维护性的倒转
    // 从复用的角度来看，高层次的模块是设计者应当复用的，但是传统的过程性的设计中，复用却侧重于具体的层次的复用，比如算法的复用，数据结构的
    // 复用，函数库的复用，都不可为避免的是具体的层次模块的复用，较高层次的结构依赖于较低层次的结构，层次的结构又依赖于更加低层次的结构，
    // 如此继续，直到依赖于每一行的代码，较低层次的修改，会造成较高层次的修改，直到高层次的逻辑的修改
    // 同样的，传统的做法也是强调具体上的可维护性，包括一个函数，数据结构，等的可维护性，而不是高级层次上的可维护性
    // 从复用的意义上来讲，既然抽象层次含有一个应用系统的最重要的宏观商务逻辑，是做战略判断的决定的地方，那么抽象层次就应当较为稳重，应当
    // 是重点中的重点，由于由于现有的复用侧重于模块和细节的复用，因此，倒转，一词，则是指定利用应当的将复用的重点放在抽象层次上，如果抽象
    // 层次的模块相对于具体的层次的模块的话，那么抽象层次的模块的利用便是相对较为容易的了
    // 两样的，最重要的宏观的商务逻辑也应当是维护的重点，而不是相反的
    // 因此，遵守依赖倒转的原则会带来复用和可维护性的倒转，好了，现在我们就来看看依赖倒转的原则是怎样的表述的吧
    // 依赖倒转的原则，关系有什么种类
    // 三种耦合的关系
    // 在面向对象的系统里
    // 两个类之间可以发生三种不同的耦合关系
    // 零耦合： 如果两个类没有耦合关系，我们称为零耦合关系
    // 具体的耦合关系，具体性耦合发生在两个具体的可实例化的类之间，经由一个类对另一个类的具体的直接的引用造成的
    // 抽象耦合关系：抽象耦合关系发生成一个具体的类和一个抽象的类，或者 java接口之间的，使两个类必须发生类之间的存在的最大的灵活性的关系
    //

    // 什么是依赖倒转原则
    // 简单的来说，依赖倒转原则要求客户端依赖于抽象的耦合，依赖倒转原则的表述是
    // 抽象不应当依赖于细节 ，细节应当依赖于抽象
    // 依赖倒转原则的另一种的表述是
    // 要针对接口编程，不应当针对实现编程
    // 第二种表述是 一书所强调的
    // 针对接口编程的意思就是说，应当使用 java 接口和抽象的 java 类进行变量的类型声明参量的类型声明，方法返回类型的声明，以及数据类型的转换
    // 要保证做到这一点的一个具体的 java 类应当只实现 java 接口和抽象java 类中的声明过的方法，而不应当给出多余的方法
    // 依赖关系强调的是一个系统的内部的实体之间的关系的灵活性，基本上，如果设计希望遵守开闭原则，那么依赖原则便是达到要求的途径
    // 变量的静态类型和真实类型
    // 变量被声明的类型叫做变量的静态类型，有些作者把静态类型称为明显类型，变量所以引用的对象的真实类型叫做变量的实际类型
    // List employees = new Vecto();
    // 显然，在上面的程序代码中，emplyees 变量的静态类型是 List,而它的实际类型是 Vector
    // 引用对象的抽象类型
    // 在很多的情况下，一个 java 程序需要引用一个对象，这个时候，如果这个对象有一个抽象类型的话，应当使用这个抽象类型作为变量的静态类型
    // 这就是针对接口的编程的含义
    // 如果蛋代表抽象，鸡代表具体，那么仍然套用先有鸡再有蛋的话题，依赖倒转原则相当于在说鸡应当依赖于蛋，而蛋不应当依赖于鸡，先有蛋再有鸡
    // 假设蛋 就是 java 接口或者 java 抽象类，鸡是一个具体的类，X 是一个变量，那么这个变量的声明应当是下面的样子
    // 蛋 x = new 鸡()
    // 而不应当是
    // 鸡 c = new 鸡（）;

}
