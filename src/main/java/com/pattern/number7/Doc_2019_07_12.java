package com.pattern.number7;

public class Doc_2019_07_12 {
    // 工厂模式的几种形态
    // 工厂模式专门负责将大量的共同接口的类实例化，工厂模式可以动态的决定将哪一个类实例化，不必事先知道每次要实例化的哪一个类.工厂模式
    // 以下的几种形态
    // 简单的工厂模式: 又称为多态性的工厂模式或虚拟的构造子模式
    // 抽象工厂模式：又称工具箱模式
    // 简单的工厂模式：又称为静态工厂模式，是不同的工厂方法模式的一个特殊实现，在其他的文献中，简单的工厂模式往往作为普通的工厂一个特例
    // 讨论
    // 在java语言中，通常的工厂方法模式不能通过设计功能的退化给出静态工厂方法模式，因为一个方法是不是静态的，对于java语言来说是一个很大的
    // 必须在一开始的时候就加以讨论，这就是这本书将简单的工厂单独的提出来讨论的原因，学习简单的工厂模式对学习工厂方法模式的一个很好的
    // 准备，也是对学习其他的模式，特别是单例模式和多例模式的一个很好的准备，这就是本书首先讲解一个模式的另一个原因
    // 角色也结构
    // 角色与结构
    // 简单的工厂模式就是由一个工厂类根据传入的参量决定创建出哪一种产品类型，下面以一
    // 从上图可以看出，工厂模式涉及到工厂角色，抽象产品角色以及具体的产品角色等三个角色
    // 工厂类的角色：担任这个角色的是工厂方法模式核心，含有与应用紧密相关的商业逻辑，工厂类在客户端直接调用下创建产品对象，它往往由一个
    // 具体的类java 类实现
    // 抽象和产品角色:担任这个角色的类是由工厂方法模式所创建的对象，它往往是由一个具体的java类实现
    // 抽象产品的角色，担任这个角色的类是由工厂模式所创建的对的父类，或它们共同拥有的接口，抽象产品角色可以用这个java接口或者java抽象实现
    // 使用java接口或者java抽象类
    // 如果模式所产生的具体的产品类彼此之间没有共同的商业逻辑，那么抽象产品的角色可以由一个java接口来扮演，相反，如果这些具体的产品类彼此之间
    // 确实有共同的商业逻辑，那么这些公有的逻辑就应当移到抽象的角色里，这就意味着抽象角色应当由一个抽象类扮演，在一个类的等级结构里，共同的
    // 代码应当尽量向上移动，以达到共享目的
    // 每个工厂类可以有一个多于一个工厂的方法，分别负责创建不同的产品对象，比如java.text.DateFormat类是其子类的工厂类，而dateformate类就
    // 提供了静态工厂方法
    // 抽象产品的角色的省略
    // 如果系统仅有一个具体的产品的角色的话，那么就可以省略抽象产品的角色，
    // 每个工厂类可以有多于一个工厂的方法，分别负责创建不同的产品对象，比如，java.text.DateFormat类是其子类的工厂类，而DateFormate类
    // 提供了多个静态方法，请参见本章的后面的说以讲解
    // 抽象产品角色的省略
    // 如果系统仅有一个具体的产品角色的话，使用java接口或者java抽象类
    // 如果模式所产生的具体的和产品类彼此之间没有共同的
    // 显然，三个原本独立的角色，工厂角色，抽象产品以及具体的产品角色都已经合并成一个类，这个类自己创建自己的实例，如下代码所示
    // 这种退化的简单的工厂模式与单例模式以及多例模式有相似之处，但是并不等于单例或才多例模式，关于这一点讨论请参考本章后面的叙述
    // 产品对象的循环使用和登记方式的工厂方法
    // 由于简单的工厂模式是一个非常基本的设计模式，因此它会在较为复杂的设计模式中出现，在本章前面所给出的要注意性例子中，工厂方法总是简单的调用
    // 产品的类型的构造以创建出一个新的产品实例，然后将这个实例提供给客户端，而实际情形中，工厂方法所做的事情可以相当的复杂
    // 本书所讨论的所有的设计模式中，单例模式也多例模式是建立在简单的工厂模式的基础之间的
    // 而且它们都要求工厂方法具有特殊的逻辑，以便能循环的使用和产品的实例
    // 在很多的情况下，产品对象可以循环使用，工厂方法可以循环的使用已经创建出来的对象，而不是每一次都创建新的产品对象，工厂方法可以通过登记它
    // 所创建的和产品对象来达到循环使用产品的对象的目的
    // 如果工厂方法总是循环的使用同一个产品对象，那么这个工厂对象可以使用一个属性来存储这个产品对象，每一次客户端调用工厂方法时，向外界提供一个
    // 惟一的单例类实例
    // 如果工厂方法永远的循环的使用固定数目的一些产品对象的，而且这些产品对象的数目并不大的话，可以使用一些私有的属性存储这些产品对象的引用
    // 比如使一个永远只提供一个产品对象的工厂对象可以使用一个静态变量存储对这个产品对象的引用
    // 相反，如果工厂方法使用的数目不确定的话，或者数目较大的一些产品对象的话，使用属性变量储存这些产品对象的引用就不方便了，这个时候
    // 就应当使用聚集对象存储对产品对象的引用
    // 不管使用哪一种方法，工厂方法都可以做到循环的使用它所创建的产品对象，循环的逻辑可能是基于这些产品类的内部的状态的，比如某一种状态的
    // 产品对象创建一个，让所有的需要处于这一状态上的产品对象的客户端共享这一个实例
    // 简单的工厂模式与其他的模式的关系
    // 单例模式
    // 单例模式使用了简单的工厂模式，单例类具有一个静态工厂方法提供自身的实例，一个抽象产品类同时是子类的工厂
    // 但是单例模式并不是简单的工厂模式的退化的情形，单例模式要求单例类的构造子是私有的，从而客户端不能直接将之实例化，而必须 通过个这
    // 静态工厂方法将之实例化，而且单例类自身是自己的工厂角色，单例类自己负责创建自身的实例
    // 单例类使用一个静态属性存储自己的唯一实例，工厂方法永远仅提供这一个实例
    // 多例模式
    // 多例模式是对单例模式的推广，多例模式与单例模式的共同之处在于它们都禁止也外界直接将之实例化，同时通过静态工厂方法向外界提供循环使用
    // 的自身实例，它们的不同在于单例模式仅有一个实例，而多例模式有多个实例
    // 多例模式往往具有一个聚集的属性，通过向这个聚集的属性登记已经创建过的实例达到循环使用实例的目的，一般而言，一个典型的多例类具有某种
    // 内部状态，这个内部状态可以用来区分和个实例，而对应的每一个内部的状态，都只有一个实例存在
    // 根据外界传入的柔肠寸断 ，工厂方法可以查询自己登记的聚集，如果一个具体的这个状态的实例已经存在，就直接将这个实例提供给外界，反之
    // 就首先创建一个新的满足要求的实例
    // 备忘录模式
    // 单例模式和多例模式使用一个属性或者聚集属性来登记所有的创建的产品对象，以便可以通过查询这个属性或者聚集属性找到并共享已经创建的产品的
    // 对象，这就是备忘录模式应用，备忘录模式的简略类图如下图所示
    // mvc模式
    // MVC 模式并不是严格意义上的设计模式，而是在更高层次中的架构模式，mvc模式可以分解成几个设计模式的组合，包括合成模式，策略模式，观察者
    //模式，也是可能会包括装饰模式，调停者模式，迭代子模式以及工厂模式方法模式，mvc模式的结构图如下所示，关于mvc模式的讨论，可以参考本书的
    // 专题mvc模式也用户的输入数据检查
    // 简单的工厂模式所创建的对象往往属于一个产品的等级结构，这个等级结构可以在mvc模式中的视图，而工厂本身的可是是控制器，一个mvc模式可以
    // 控制多个视图
    // 控制器端可以创建你合适的视图端，就如同工厂角色创建合适的对象角色一样，而模式端则可以充当这个创建过程的客户端
    // 如果系统需要多个控制器双面性这个过程的话，简单工厂模式就不适合了，应当考虑使用工厂方法模式，
    // 简单的工厂模式的优点
    // 模式的核心工厂类，这个类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，而客户端则可以免除直接的创建产品对象的责任
    // 不仅仅负责消费产品的简单工厂模式通过这做做法实现了对责任的分割
    // 简单工厂模式的缺点
    // 正如同本章前面的所讨论的，产品的类有复杂的多层次的等级结构时，工厂类只有它自己，以不变应万变，这就是模式的缺点
    // 这个工厂类集 中了所有的产品的创建逻辑，形成了一个无所不知的全能的类，有人把这种类叫做上帝类，如果这种全能的类代表的是农场的一个具体的
    // 园丁的话，那么这个园丁就对所有的产品负责，成了农场的关键人物，他什么时候不能正常工作了，整个农场都将受到影响
    // 将这么多的逻辑集中放在一个类里面的另一个缺点就是，当产品类不同的接口种类时，工厂类需要判断在什么时候创建某种产品，这种对时机的判断和对
    // 哪一种具体的产品的判断逻辑混合在一起，使得系统在将来进行功能的扩展的时候较为困难，这一缺点在工厂方法模式中得到克服
    // 由于简单的工厂模式的使用静态方法作为工厂方法，而静态的方法无法由子类继承，因此工厂角色无法形成继承的等级结构，这一缺点会在工厂方法模式中
    // 得克服
    // 由于简单的工厂模式使用的地静态的方法作为工厂方法，而静态的方法无法由子类继承，因此工厂方角色无法形成继承等级结构
    // 将这么多的逻辑中放在一个类里面的另一个缺点就是，当产品类不同的接口类时，工厂类需要判断在什么时候创建某个产品，这种对时间的判断和对
    // 另一个产品的判断逻辑混合在一起，使得系统在将来进行功能的扩展的时候较为困难，这和缺点在工厂方法模式中得到克服
    // 开闭原则
    // 开闭原则要求一个系统的设计能够允许系统在无需修改的情况扩展其功能,那么简单的工厂模式是否满足这个条件呢
    // 要想回答这个问题，首先需要将系统划分成不同的子系统，再考虑功能的扩展对于这些子系统的要求，一般而言，一个系统总是可以划分成为产品的
    // 的消费者的角色，产品的工厂角色，以及产品的角色，三个子系统
    // 在这个系统中，功能的扩展体现在引进新的产品上，开闭原则要求系统允许当新的产品加入系统中时，而无需对现有的代码进行修改，这一点对于产品
    // 消费的角色是成立的，而对于工厂角色是不成立的
    // 对于产品的消费角色来说，任何的时候需要某种产品，只需要工厂角色中请求就可以了，而工厂角色接收到请求以后，会自行的判断创建和提供哪一个
    // 产品，所以，产品的角色无需知道它得到的哪一个产品，产品的消费角色无需修改就可以接纳新的产品
    // 对于工厂来说，增加新的产品是一个痛苦的过程，工厂的角色必须知道每一种产品，如果创建他们，以及何时向客户端提供它们，接纳新的产品
    // 意味着需要修改这个工厂角色的源代码
    // getDateinstance() 方法并没有调用DateFormat的构造子来提供自己的实例，作为一个工厂方法，getDateInstance()应该就地做了一些有趣的
    // 事情，它所做的事情基本可以分成两分，一个运用多态性，二是使用静态工厂方法
    // 从上面给出的DateFormat和SimpleDateFormat 的类图可以看出，SimpleDateFormat是抽象的，DateFormat是具体的的子类，这就意味着SimpleDateFormate
    // 的实例，并且仅仅将它声明为DateFormat类型，这就是最纯正的多态性原则的运用
    // getDateInstance()方法是一个静态的方法，如果它是一个非静态的普通方法会怎样呢，要使用这个非静态的方法，客户端必须首先取得这个类的
    // 实例，或者其子类的实例，而这个类的是一个抽象类，不可能有自己的实例，所以客户端就只好首先取得具体的子类的实例，如果客户端能够取得它
    // 的子类的实例，那么需要工厂方法将没有什么意思
    // 显然，这里使用静态工厂方法是为了具体的子类实例工厂隐藏起来，从而客户端不必考虑如何将具体的子类实例化，因为抽象类DateFormat会提供
    // 它合适的具体的子类的实例，这是一个简单的工厂方法模式的绝佳应用
    // 针对抽象编程
    // 这样做是利用具体产品的类的超类类型将它真实类型隐藏起来，其好处就是提供了系统的可扩展性，如果将来有新的具体的子类被加入到系统中来，那
    // 工厂类可以将给客户端的对象换成新的子类的实例，而对客户端没有任何的影响
    // 这种将工厂方法的返回类设计成抽象产品的类型的做法，叫做针对抽象编程，这是依赖倒转的原则的应用，关于这一设计原则的详细讨论
    // 本地时间
    // 与本地日期格式化相对应的是为了某种本地时间提供格式化，这一功能由三个重载的getTimeInstance()方法提供
    // 好的多行
    // 单行 编辑器
    // 在SAX2库中的，XMLReaderFactory类使用简单的工厂械，用来创建产品类XMLRreader的实例，下图所示是XMLReaderFactory和XMLReader类型关系
    // XMLReaderFactory提供也两种不同的静态方法，适用于不同的驱动软件参数
    // 一个个的人，这就是简单的工厂模式的应用
    // 本章试图使用UML和模式的语言来解释女娲的做法，首先，在这个造人的思想里，有几个重要的角色，女娲本身，抽象的人的概念和女娲造出具体的人
    // 女娲是一个工厂类，也就是简单的工厂和女娲所选出的具体的人
    // 具体的一个个人，包括张三，李四，这些人便是简单的工厂模式里面的具体的和产品角色
    // 抽象的人便是最早的存在于女娲的头脑里的一个想法，女娲按照这个想法造出一个个具体的人便是符合这个抽象的人的定义的，这个抽象的想法规定了
    // 所有具体的人必须具有的接口
    // 



























}
