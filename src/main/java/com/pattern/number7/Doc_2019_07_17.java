package com.pattern.number7;

public class Doc_2019_07_17 {


    //一个系统需要消费多个抽象产品角色，这些抽象产品角色可以用 Java 接口或者抽象 Java 类实现。
    // 读过本书的“工厂方法（Factory Method）模式”一章的读者可能会建议，既然客户端需要这些抽象产品角色的实例，
    // 为什么不使用一个工厂类负责创建这些角色的实例呢？工厂类负责创建抽象产品的实例描述如下图所示。
    // IText for mac（简单易用的 OCR 文字识别工具）v1.5.0 无限试用版
    //
   // 但是，正如。上面所指出的，这些抽象产品角色是由 Java 接口或者抽象 Java 类实现的，而一个 Java 接口或者抽象 Java 类是不能实例化的。也就是说，上面的设计是不能成立的。。

    //第二段

    //那么怎么满足系统的需求呢？

    //根据里氏代换原则，任何接收父类型的地方，都应当能够接收子类型。因此，实际上系统所需要的，
    // 仅仅是类型与这些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。换言之，也就是这些抽象产品的具体子类的实例。工厂类负责创建抽象产品的具体子类的实例如下图所示。
    // 那么怎么满足系统的需求呢？
    // 那么怎么满足系统的需求呢？
    //   根据里氏代换原则，任何接收父类型的地方，都应当能够接收子类型。因此，实际上系统所需要的，仅仅是类型与这些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。换言之，也就是这些抽象产品的具体子类的实例。工厂类负责创建抽象产品的具体子类的实例如下图所示。
    // 在上面的坐标图中，横轴表示产品的等级结构，纵轴表示产品族，可以看出，图中一共有四个产品族，分布于三个不同的产品等级结构中，只要
    // 指明一个产品所处的产品族以及它的属性的等级结构，就可以唯一的确定这个产品
    // 这样的坐标图中，叫做相图，在一个相图中，坐标轴代表的是抽象自由度，相图中两个坐标点之间的xqce距离并没有意义，有意义的是点与点相对的
    // 位置
    // 引进抽象工厂模式
    // 上面所给出的三个不同等级结构具有平行的结构，因此，如果采用工厂方法模式就势必要使用三个独立的工厂等级结构来对付这三个产品的等级结构，
    // 由于三个产品的等级结构有相似性，就会导致三个平行的工厂等级结构，随着产品等级结构的数目增加，工厂方法模式所给出的工厂等级结构的数目
    // 也会相应的随之增加
    // 那么，是否可以使用同一个工厂等级结构来对付这些相同或者极为相似的产品等级结构呢？当然是可以的，而且这就是抽象工厂模式的好处，同一个
    // 工厂等级结构负责三个不同的产品等级结构的产品对象来创建，如下图所示，图中的虚线借还创建关系
    // 可以看出，一个工厂等级结构可以创建分属于不同产品等级结构的一个产品族中的所有对象，显然，这个时候，抽象工厂模式比工厂方法模式更加有
    // 效率我觉得是好的,我觉得是好的，因为他们东西是这样的
    // 从上面可以看出，一个工厂每组结构可以创建出分发于不同的产品等级结构的一个产品族作为讲解的例子，但是真实的系统中，产品话谢往往具有
    // 复杂的等级结构，就如同上面的图中所描述的一样，可以具有多于一个抽象产品和很多的具体产品
    // 在上面的相图中加入了具体的工厂角色，可以看出，对于产品族都一有一个具体的工厂，而每一个具体的工厂负责创建属于一个产品族，但是分属
    // 于不同的等级结构的产品中
    // 抽象工厂模式是对象的创建模式，它是工厂方法模式的进一步推广
    // 假设一个子系统需要一些责任和创建这些对象的不用什么分割开来，而这些产品又属于一个以上的产品等级结构，那么为了将消费这引进产品对象的责任
    // 分割开来，可以抽象工厂模式，这样的话，消费产品一方不需要直接参与产品的创建工作，而只需要向一个公用的工厂接口请求需要产品
    // 产品对象的创建问题
    // 通过使用抽象工厂模式，可以处理具有相同的或者相似等级结构的多个产品族中的产品对象创建问题，如下图所示，就是两个具体的相同等级结构产品
    // 族，和产品等级结构B的结构
    // 如果使用相同的描述的话，会看到在相同的上出现两个每组结构的A和B
    // 在上面的相图中，每一个坐标点都代表一个具体产品角色，可以看出，坐标点（A,1）(B,1)(A,2)(B,2) 分别对应于具体的产品角色，ProductA1
    // ProductA2,ProductB1,ProductB2,
    // 就像本章前面的所谈到的一样，如果使用工厂方法模式处理的话，就必须要有两个独立的工厂族，由于这两个产品族的等级结构相同，因此，使用
    // 同一个工厂族也可以处理这两个产品族的等级结构相同，因此，使用同一个工厂族也可以处理这两个产品创建的问题，后者就是抽象工厂模式，这样
    // 根据产品角色的结构图，就不难给出工厂角色的结构设计图，如，下图，所示，
    // 由于每个具体的工厂角色都需要负责两个不同等级结构的产品，对象的创建，因此，每个工厂角色，都需要提供两个，工厂方法，分别用于创建两个，
    // 等级结构产品，既然每个具体的工厂角色都需要实现这两个工厂方法，所以，这种情况就具有一般性，不妨，抽象出来，移动到抽象工厂角色Creator
    // 中加以声明，产品等级结构A和产品等级结构B的结构图如下图所示
    // 可以看出，每一个工厂角色都有两个工厂方法，分别负责创建分属于不同产品等级结构的产品对象，
    // 系统的设计
    // 采用抽象工厂模式设计的系统类图所示
    // 从上图所示看出，抽象工厂模式涉及到以下角色
    // 抽象工厂角色，担任这个角色的工厂方法模式的核心，它是与应用系统的商业逻辑无关的，
    // 具体 工厂类角色，这个角色直接在客户端的调用下创建产品的实例，
    // 具体工厂类（Concrete Factory）角色：这个角色直接在客户端的调用下创建产品的实例。这个角色含有选择合适的产品对象的逻辑，
    // 而这个逻辑是与应用系统的商业逻辑紧密相关的。通常使用具体 Java 类实现这个角色。
    // 抽象产品（Abstract Product）角色：担任这个角色的类是工厂方法模式所创建的对象的父类，或它们共同拥有的接口。通常使用 Java 接口或者抽象 Java 类实现这一角色。
    // 具体产品（Concrete Product）角色：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。这是客户端最终需要的东西
    // ，其内部一定充满了应用系统的商业逻辑。通常使用具体 Java 类实现这个角色。
    // 在什么情况下应用使用抽象工厂模式
    // 在以下的情况下应当考虑使用抽象工厂模式
    // 一个系统应当依赖于产品类实例如何被创建，组合和表达细节，这对于所有形态的工厂模式都重要的
    // 同属于同一个产品族的产品是在一起使用，这一约束必须在系统的设计中体现出来，
    // 系统提供了一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现
    // 很多从都会问同样的问题，为什么在第二条中说，系统只消费其中的一族中的产品，这实际上与抽象工厂模式起源有关
    // 抽象工厂模式的起源或者说是最早的应用，是用于创建分属不同操作系统的视窗构件，比如，命令按键，与文字的视窗构件，在UniX操作系统的视窗
    // 环境和Winwdows操作系统的视窗环境中，这两个构件有不同的本地实现，它们的细节也有不同
    // 在每一个操作系统中，都有一个视窗构件组成的构件家族，在这里就是button和Text组成的产品族，而每一个视窗构件都构成自己的等级结构
    // 可以发现在上面的产品类图中，有两个产品的等级结构，分别是buttton等级结构和Text等级结构，同时有两个产品族，也就是Unix产品族，
    // 和Window产品族，UnitButton和UnixText产品构成，而Window产品族，由WindowButton和WindText产品构成，其相图的描述如下图所示
    // 系统对产品对象的创建需求由一个工厂等级结构满足，其中有两个具体的角色，即，UnixFactory 和 WinFactory，对象负责创建Unix产品族
    // 中的产品，而WinFactory 对象负责创建Windows产品族中的产品，这就是抽象工厂模式的应用，抽象工厂模式的解决如下图所示
    // 显然，一下系统只能够在某一个操作系统的视窗环境下运行，而不能同时在不同的操作系统上运行，所以，系统实际上只能消费属于同一个产品族
    // 的产品
    // 在现代的应用中，抽象工厂模式的使用范围已经大大的扩大了，不要要求系统只能消费某一个产品族，因此，读者可以不理会前面所提到的原始用意
    // 抽象工厂模式在农场系统中的实现
    // 本节考察一下如何扩展本书中在简单工厂模式以及工厂方法模式，两章中所讨论的农场系统
    // 本书在简单工厂模式与工厂方法模式两章中曾经仔细讨论过一个农场公司从小大到发展过程，而如今，农场公司再次面临新的大发展，一项重要工作
    // 就是引进


























}
