package com.pattern.number7;

public class Doc_2019_07_17 {


    //一个系统需要消费多个抽象产品角色，这些抽象产品角色可以用 Java 接口或者抽象 Java 类实现。
    // 读过本书的“工厂方法（Factory Method）模式”一章的读者可能会建议，既然客户端需要这些抽象产品角色的实例，
    // 为什么不使用一个工厂类负责创建这些角色的实例呢？工厂类负责创建抽象产品的实例描述如下图所示。
    // IText for mac（简单易用的 OCR 文字识别工具）v1.5.0 无限试用版
    //
   // 但是，正如。上面所指出的，这些抽象产品角色是由 Java 接口或者抽象 Java 类实现的，而一个 Java 接口或者抽象 Java 类是不能实例化的。也就是说，上面的设计是不能成立的。。

    //第二段

    //那么怎么满足系统的需求呢？

    //根据里氏代换原则，任何接收父类型的地方，都应当能够接收子类型。因此，实际上系统所需要的，
    // 仅仅是类型与这些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。换言之，也就是这些抽象产品的具体子类的实例。工厂类负责创建抽象产品的具体子类的实例如下图所示。
    // 那么怎么满足系统的需求呢？
    // 那么怎么满足系统的需求呢？
    //   根据里氏代换原则，任何接收父类型的地方，都应当能够接收子类型。因此，实际上系统所需要的，仅仅是类型与这些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。换言之，也就是这些抽象产品的具体子类的实例。工厂类负责创建抽象产品的具体子类的实例如下图所示。
    // 在上面的坐标图中，横轴表示产品的等级结构，纵轴表示产品族，可以看出，图中一共有四个产品族，分布于三个不同的产品等级结构中，只要
    // 指明一个产品所处的产品族以及它的属性的等级结构，就可以唯一的确定这个产品
    // 这样的坐标图中，叫做相图，在一个相图中，坐标轴代表的是抽象自由度，相图中两个坐标点之间的xqce距离并没有意义，有意义的是点与点相对的
    // 位置
    // 引进抽象工厂模式
    // 上面所给出的三个不同等级结构具有平行的结构，因此，如果采用工厂方法模式就势必要使用三个独立的工厂等级结构来对付这三个产品的等级结构，
    // 由于三个产品的等级结构有相似性，就会导致三个平行的工厂等级结构，随着产品等级结构的数目增加，工厂方法模式所给出的工厂等级结构的数目
    // 也会相应的随之增加
    // 那么，是否可以使用同一个工厂等级结构来对付这些相同或者极为相似的产品等级结构呢？当然是可以的，而且这就是抽象工厂模式的好处，同一个
    // 工厂等级结构负责三个不同的产品等级结构的产品对象来创建，如下图所示，图中的虚线借还创建关系
    // 可以看出，一个工厂等级结构可以创建分属于不同产品等级结构的一个产品族中的所有对象，显然，这个时候，抽象工厂模式比工厂方法模式更加有
    // 效率我觉得是好的,我觉得是好的，因为他们东西是这样的
    // 从上面可以看出，一个工厂每组结构可以创建出分发于不同的产品等级结构的一个产品族作为讲解的例子，但是真实的系统中，产品话谢往往具有
    // 复杂的等级结构，就如同上面的图中所描述的一样，可以具有多于一个抽象产品和很多的具体产品
    // 在上面的相图中加入了具体的工厂角色，可以看出，对于产品族都一有一个具体的工厂，而每一个具体的工厂负责创建属于一个产品族，但是分属
    // 于不同的等级结构的产品中
    //



























}
