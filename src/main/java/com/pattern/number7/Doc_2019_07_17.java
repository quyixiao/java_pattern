package com.pattern.number7;

public class Doc_2019_07_17 {


    //一个系统需要消费多个抽象产品角色，这些抽象产品角色可以用 Java 接口或者抽象 Java 类实现。
    // 读过本书的“工厂方法（Factory Method）模式”一章的读者可能会建议，既然客户端需要这些抽象产品角色的实例，
    // 为什么不使用一个工厂类负责创建这些角色的实例呢？工厂类负责创建抽象产品的实例描述如下图所示。
    // IText for mac（简单易用的 OCR 文字识别工具）v1.5.0 无限试用版
    //
    // 但是，正如。上面所指出的，这些抽象产品角色是由 Java 接口或者抽象 Java 类实现的，而一个 Java 接口或者抽象 Java 类是不能实例化的。也就是说，上面的设计是不能成立的。。

    //第二段

    //那么怎么满足系统的需求呢？

    //根据里氏代换原则，任何接收父类型的地方，都应当能够接收子类型。因此，实际上系统所需要的，
    // 仅仅是类型与这些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。换言之，也就是这些抽象产品的具体子类的实例。工厂类负责创建抽象产品的具体子类的实例如下图所示。
    // 那么怎么满足系统的需求呢？
    // 那么怎么满足系统的需求呢？
    //   根据里氏代换原则，任何接收父类型的地方，都应当能够接收子类型。因此，实际上系统所需要的，仅仅是类型与这些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。换言之，也就是这些抽象产品的具体子类的实例。工厂类负责创建抽象产品的具体子类的实例如下图所示。
    // 在上面的坐标图中，横轴表示产品的等级结构，纵轴表示产品族，可以看出，图中一共有四个产品族，分布于三个不同的产品等级结构中，只要
    // 指明一个产品所处的产品族以及它的属性的等级结构，就可以唯一的确定这个产品
    // 这样的坐标图中，叫做相图，在一个相图中，坐标轴代表的是抽象自由度，相图中两个坐标点之间的xqce距离并没有意义，有意义的是点与点相对的
    // 位置
    // 引进抽象工厂模式
    // 上面所给出的三个不同等级结构具有平行的结构，因此，如果采用工厂方法模式就势必要使用三个独立的工厂等级结构来对付这三个产品的等级结构，
    // 由于三个产品的等级结构有相似性，就会导致三个平行的工厂等级结构，随着产品等级结构的数目增加，工厂方法模式所给出的工厂等级结构的数目
    // 也会相应的随之增加
    // 那么，是否可以使用同一个工厂等级结构来对付这些相同或者极为相似的产品等级结构呢？当然是可以的，而且这就是抽象工厂模式的好处，同一个
    // 工厂等级结构负责三个不同的产品等级结构的产品对象来创建，如下图所示，图中的虚线借还创建关系
    // 可以看出，一个工厂等级结构可以创建分属于不同产品等级结构的一个产品族中的所有对象，显然，这个时候，抽象工厂模式比工厂方法模式更加有
    // 效率我觉得是好的,我觉得是好的，因为他们东西是这样的
    // 从上面可以看出，一个工厂每组结构可以创建出分发于不同的产品等级结构的一个产品族作为讲解的例子，但是真实的系统中，产品话谢往往具有
    // 复杂的等级结构，就如同上面的图中所描述的一样，可以具有多于一个抽象产品和很多的具体产品
    // 在上面的相图中加入了具体的工厂角色，可以看出，对于产品族都一有一个具体的工厂，而每一个具体的工厂负责创建属于一个产品族，但是分属
    // 于不同的等级结构的产品中
    // 抽象工厂模式是对象的创建模式，它是工厂方法模式的进一步推广
    // 假设一个子系统需要一些责任和创建这些对象的不用什么分割开来，而这些产品又属于一个以上的产品等级结构，那么为了将消费这引进产品对象的责任
    // 分割开来，可以抽象工厂模式，这样的话，消费产品一方不需要直接参与产品的创建工作，而只需要向一个公用的工厂接口请求需要产品
    // 产品对象的创建问题
    // 通过使用抽象工厂模式，可以处理具有相同的或者相似等级结构的多个产品族中的产品对象创建问题，如下图所示，就是两个具体的相同等级结构产品
    // 族，和产品等级结构B的结构
    // 如果使用相同的描述的话，会看到在相同的上出现两个每组结构的A和B
    // 在上面的相图中，每一个坐标点都代表一个具体产品角色，可以看出，坐标点（A,1）(B,1)(A,2)(B,2) 分别对应于具体的产品角色，ProductA1
    // ProductA2,ProductB1,ProductB2,
    // 就像本章前面的所谈到的一样，如果使用工厂方法模式处理的话，就必须要有两个独立的工厂族，由于这两个产品族的等级结构相同，因此，使用
    // 同一个工厂族也可以处理这两个产品族的等级结构相同，因此，使用同一个工厂族也可以处理这两个产品创建的问题，后者就是抽象工厂模式，这样
    // 根据产品角色的结构图，就不难给出工厂角色的结构设计图，如，下图，所示，
    // 由于每个具体的工厂角色都需要负责两个不同等级结构的产品，对象的创建，因此，每个工厂角色，都需要提供两个，工厂方法，分别用于创建两个，
    // 等级结构产品，既然每个具体的工厂角色都需要实现这两个工厂方法，所以，这种情况就具有一般性，不妨，抽象出来，移动到抽象工厂角色Creator
    // 中加以声明，产品等级结构A和产品等级结构B的结构图如下图所示
    // 可以看出，每一个工厂角色都有两个工厂方法，分别负责创建分属于不同产品等级结构的产品对象，
    // 系统的设计
    // 采用抽象工厂模式设计的系统类图所示
    // 从上图所示看出，抽象工厂模式涉及到以下角色
    // 抽象工厂角色，担任这个角色的工厂方法模式的核心，它是与应用系统的商业逻辑无关的，
    // 具体 工厂类角色，这个角色直接在客户端的调用下创建产品的实例，
    // 具体工厂类（Concrete Factory）角色：这个角色直接在客户端的调用下创建产品的实例。这个角色含有选择合适的产品对象的逻辑，
    // 而这个逻辑是与应用系统的商业逻辑紧密相关的。通常使用具体 Java 类实现这个角色。
    // 抽象产品（Abstract Product）角色：担任这个角色的类是工厂方法模式所创建的对象的父类，或它们共同拥有的接口。通常使用 Java 接口或者抽象 Java 类实现这一角色。
    // 具体产品（Concrete Product）角色：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。这是客户端最终需要的东西
    // ，其内部一定充满了应用系统的商业逻辑。通常使用具体 Java 类实现这个角色。
    // 在什么情况下应用使用抽象工厂模式
    // 在以下的情况下应当考虑使用抽象工厂模式
    // 一个系统应当依赖于产品类实例如何被创建，组合和表达细节，这对于所有形态的工厂模式都重要的
    // 同属于同一个产品族的产品是在一起使用，这一约束必须在系统的设计中体现出来，
    // 系统提供了一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现
    // 很多从都会问同样的问题，为什么在第二条中说，系统只消费其中的一族中的产品，这实际上与抽象工厂模式起源有关
    // 抽象工厂模式的起源或者说是最早的应用，是用于创建分属不同操作系统的视窗构件，比如，命令按键，与文字的视窗构件，在UniX操作系统的视窗
    // 环境和Winwdows操作系统的视窗环境中，这两个构件有不同的本地实现，它们的细节也有不同
    // 在每一个操作系统中，都有一个视窗构件组成的构件家族，在这里就是button和Text组成的产品族，而每一个视窗构件都构成自己的等级结构
    // 可以发现在上面的产品类图中，有两个产品的等级结构，分别是buttton等级结构和Text等级结构，同时有两个产品族，也就是Unix产品族，
    // 和Window产品族，UnitButton和UnixText产品构成，而Window产品族，由WindowButton和WindText产品构成，其相图的描述如下图所示
    // 系统对产品对象的创建需求由一个工厂等级结构满足，其中有两个具体的角色，即，UnixFactory 和 WinFactory，对象负责创建Unix产品族
    // 中的产品，而WinFactory 对象负责创建Windows产品族中的产品，这就是抽象工厂模式的应用，抽象工厂模式的解决如下图所示
    // 显然，一下系统只能够在某一个操作系统的视窗环境下运行，而不能同时在不同的操作系统上运行，所以，系统实际上只能消费属于同一个产品族
    // 的产品
    // 在现代的应用中，抽象工厂模式的使用范围已经大大的扩大了，不要要求系统只能消费某一个产品族，因此，读者可以不理会前面所提到的原始用意
    // 抽象工厂模式在农场系统中的实现
    // 本节考察一下如何扩展本书中在简单工厂模式以及工厂方法模式，两章中所讨论的农场系统
    // 本书在简单工厂模式与工厂方法模式两章中曾经仔细讨论过一个农场公司从小大到发展过程，而如今，农场公司再次面临新的大发展，一项重要工作
    // 就是引进
    // 显然系统应该使用的是抽象工厂模式，而不是工厂方法模式，因为后者适合于处理只有一个产品等级结构的情形，抽象工厂模式应用于微型计算机配件
    // 从图中可以看出，每一个工厂角色都提供两个工厂方法，分别对应于两个不同的抽象产品。有多少抽象产品，就会有多少的工厂方法。
    // 限于篇幅，不再提供这个系统的详细讨论。
    // 但是，读者可以在本章后面的问答题中找到更多的关于这个系统的内容。
    // 开闭 原则要求一人软件系统可以在不修改原有代码的情况下，通过扩展达到增强其功能的目的，对于一个涉及到多个产品等级结构和多个产品族
    // 的系统，其功能增强不外乎两个方面
    // 增加新的产品族
    // 增加新的产品等级结构
    // 那么抽象工厂模式是怎样
    // 增加新的产品族
    // 在产品等级结构的数目不变的情况下，增加新产品族，就意味着在每一个产品等级结构中增加一个新的具体的或者抽象的产品角色
    // 由于工厂等级结构是产品等级结构平等的登记机构，因此，当产品等级结构有所调整时，需要将工厂等级结构做相应的调整，现在产品等级结构中
    // 出现了新的元素，因此，需要向工厂等级结构中加入相应的新的元素就可以了
    // 设计师只需要向系统中加入新的具体的工厂类就可以了，没有必要修改已有的工厂角色或者产品角色，因此，在系统中的产品族增加时，抽象工厂
    // 模式是支持开闭原则的
    // 在产品族的数目不变的情况下，增加亲的产品等级结构，所有的产品等级结构中的产品数目不会改变，但是现在多出 一个与现有的产品等级结构
    // 平等的新的产品等级结构
    // 要做到这一点，需要修改所有的工厂角色给每一个工厂类增加一个新的工厂方法，而这个显然是违背开闭原则的，综合起来，抽象工厂模式以一种
    // 倾斜的本书的一章中，还曾经谈到了简单的工厂模式，工厂角色可以与具体的工厂角色合并，如
    // 抽象工厂模式可以向客户端提供一个接口，使得客户端在不必指定产品的具体的类型的情况下，创建多个产品族中的产品对象，这就是抽象工厂模式的
    // 用意
    // 第一段
    // 一个系统需要消费多个抽象产品角色，这些抽象产品角色可以用java接口或才抽象java类来实现，读过本书工厂方法模式一章中的读者可能会建义
    // 既然客户端需要这些抽象产品角色的实例，为什么不使用一个工厂类负责的创建这些角色的实例呢，工厂类负责创建抽象产品的实例描述如下
    // 但是，正如上面所指出的，这些抽象产品角色是由java接口或者抽象java类实现的，而一个java接口或者抽象java类是不有实例化的，也就是说
    // 上面的设计是不能成立的
    // 第二段
    // 那么怎样满足系统的需求呢
    // 那么怎样满足系统的需求呢
    // 根据里氏代替原则 ，任何接收父类型的地方，都应当能够接收子类，因此，实际上系统所需要的，仅仅是类型与这些抽象和产品角色相同的一些实例
    // 而不是这些抽象产品的实例，也就是这些抽象产品的具体的子类的实例，工厂类负责创建抽象产品的具体的子类实例如下图所示
    // 这就是抽象工厂模式用意的基本含义
    // 第三段
    // 那么拉下来的一个问题就是，如果每个抽象产品都有一个具体的子类的话，工厂角色怎么知道实例化哪一个子类呢，比如下面的类图中的就给出了
    // 两个具体的抽象产品，而每一个抽象产品都有两个具体的产品
    // 抽象工厂模式提供两个具体的角色，分别对应于这两个具体的产品角色，每一个具体的工厂角色仅负责某一个具体的产品的实例化，每一个具体的工厂
    // 类负责创建抽象产品的某一个具体的实例，如下图所示
    // 抽象来自于抽象产品角色，而抽象工厂，就是抽象产品角色的工厂
    // 每一个模式都是针对一个问题解决方案，正如前面所提到的，抽象工厂模式面对的问题多个产品等级结构的系统设计，下面就是所面对的问题开始
    // 将抽象工厂模式引进到系统设计中
    // 多个产品等级结构
    // 抽象工厂模式与工厂方法模式的最大的区别就是在于，工厂方法械针对的是一个产品的等级结构 ，而抽象工厂模式则需要面对多个等级结构，下图
    // 所示的一个产品等级结构
    // 为了方便引进抽象工厂模式，特地的引进一个新的概念，产品族，所谓的产品旅行族，是指位于不同的产品等级结构中的，功能相关联的产品组成的家族
    // 箭头所指的就是三个功能相关联的产品，它们位于三个不同的等级结构中的相同的位置上，组成了一个产品族
    // 显然 ，每一个产品族中的含有产品的数目，与产品等级结构的数目是相等的，产品的等级结构和产品族将产品按照不同的方向划分，形成一个二维的
    // 坐标系
    // 在坐标图中的，横轴表示产品的结构，纵轴表示产品族，可以看出，图中的一共有四个产品产族，分布于三个不同的产品等级结构中，只要指明一个
    // 产品所处的产品族以及它所属的等级结构，就可以唯一的确定这个产品族
    // 这个坐标图，叫做相图，在一个相图中，坐标轴个代表的是自由度，相图中两个坐标点之间绝对距离没有意义，在意义是点与点的相对位置
    // 上面所给出的三个不同的等级结构具有平等的结构，因此，如果采用工厂方法模式，就势必要使用独立的工厂等级结构，随着产品等级结构实现是这样人
    // 我觉得还是好的，会导致三个平行的工厂等级结构，随着产品的等级结构的增加，工厂方法模式所给出的工厂等级结构的数目也会随着不段增加
    // 那么是不是可以使用同一个等级结构来观者对付这些相同或者极为相似的产品的等级结构，当然是可以的，而且这就是抽象工厂模式的好处，同一个
    // 工厂等级结构负责三个不同的产品等级结构 的产品对象的创建，如下图所示，图中的虚线代表着创建关系
    // 可以看出，一个工厂等级结构可以创建出属于不同的产品等级结构的一个产品簇中的所有的对象，显然，这个时候，抽象工厂模式比工厂方法模式更加
    // 有效率，
    // 应当指出的讲解的例子，但是在真实的系统中，产品族，往往具有复杂的等级结构，就如同上面的图中所描述的一样，可以具有多个抽象产品的很多的
    // 具体的产品
    // 如果使用相图来描述的话，如下图所示
    // 在上面的相图中的加入了具体的工厂角色，可以看出，对应于每一个产品族中的有一个具体的工厂，而每一个工厂负责创建属于同一个产品族
    // 但是分属等级结构的产品
    // 抽象工厂模式是对象的创建模式，它是工厂方法的模式的进一步的推广，
    // 假设一个子系统需要一些产品对象，而这些产品又属于一个以上的产品等级结构，那么将消费这些产品的对象责任和创建这些产品对象的责任分割
    // 开来，可以引进抽象工厂模式，这样的话，消费产品是一方不需要直接对参与产品的创建工作，而只需要一个向一个公用的工厂接口所需要的产品
    // 产品对象的创建问题
    // 通过使用抽象工厂模式，可以处理具有相同的或者相似的，等级结构的多个产品族中的产品对象的创建问题，如下图所示，图中的两个具体的相同的
    // 等级结构的产品族，A 和和产品等级结构 B 的 结构图
    // 如果使用相同的图描述的话，会看到，在相图上出现两个等级结构A和B，以上的两个产品族1和2 ，所下图所示
    // 在上面的相图中，每一个坐标点都代表一个具体的产品角色，可以看出，坐标点 分别对应于具体的产品角色，product A
    // 就像本章前面所谈到的一样，如果使用工厂方法模式处理的话，就必须要有两个很独立的工厂族，由于两个产品族的等级结构相同，因此，使用同
    // 也可处理这两个产品的创建问题，后者就是抽象工厂模式，这样的根据产品角色的结构图，就不难给出工厂角色的结构图的设计图，如下图所示
    // 由于每个具体的工厂角色都需要负责



























}
