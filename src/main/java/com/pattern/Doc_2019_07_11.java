package com.pattern;

public class Doc_2019_07_11 {
    // 在很多的情况下，缺乏经验的 java 设计师之所以选择继承关系描述两个类之间的关系，是因为对继承关系不理解不够造成的，而要正确地使用
    // 一般来说，对违反里氏替换原则的设计进行重构时，可以采用两个办法，一是加入一个抽象类超类，这一办法已经是本书的里氏替换原则 ，一章
    // 中讨论过，二是继承关系改写成合成聚合关系，这一点是本章讨论的重点
    // 区分 Has-A 与 is-A 是严格的分类学意义上的定义，意思是一个类是另一个类的一种而 Has-A 则不同，它表示某一个角色的具体一项责任
    // 导致错误的使用继承而不是合成聚合的一种觉的原则错误的把 Has-A 当作 is-A ，is-A 代表的是一个类的另一个特殊的种类，这是 Coad 条件的
    // 第一条，请考虑一下图所示的类图中所描述的一个例子，人被继承到雇员的，经理，和学生等子类 ，而实际上，雇员，经理，和学生分别描述的是一种
    // 角色，而人可以同时有几种不同的角色，比如一个人既然是经理，就必然是，这会使得一个人在成为雇员的身份后，就永远的为雇员，不能称为
    // 经理或者学生，而这个显然是不合理的
    // 当一个类是另一种角色的时候，不应当使用继承来描述这种关系
    // 里氏替换原则是继承利用的基石，如果任何使用 B 类型的地方都使用 S 类型，那么 S 类型才能称为 B 类型的子类型，而 B类型才能称为 S 类型的
    // 基类型
    // 只有当一个 S 在任何的情况下都是一种 B 的时候，才可以将 S 设计成 B 的子类 ，如果两个类的关系是 Has-A 关系而不是 IS-A 的关系
    // 这两个类一定违反里替换原则
    // 一个 Stack 不是一个 Vector,所以，Stack 不应当设置成为 Vector的子类 ，同样的，一个性质列不是一个 HashTable，在两种情况下
    // 使用聚合比使用继承关系更加合适
    // 由于 Properties 继承了 HashTable 的行为，因而当 p 是一个 Properties 类型的对象时，p.getProperties(key)与 p.get(key)
    // 就会给出不同的结果，前者来自于 Properties 的本身，因此会利用默认值，而后者来自于 Hashtable，因此不会利用默认值
    // 更加糟糕的是，由于 properties 是 hashTable 的子类 ，因此，客户端可以通过类型转换，直接使用超类型的行为，比如，Properties
    // 假定所有的键和值都是 String 类型的，如果不是，就导致运行崩溃，但是，客户端完全可以通过 Hashtable 提供的行为加入任意类型的
    // 键和值的，绕过 Properties 的接口，并导致 Properties 的内部矛盾和崩溃
    // 这样的来，properties 其实仅仅是一些hashTable 的属性，这是一个 hash-A 的关系，而不是一个 is-A 的关系
    // 迪米特法则，以叫做最少知识原则，一个对象应当对另一个对象有尽可能少的了解
    // 迪米特法则的各种表述
    // 没有任何的一个其他的 oo 设计原则像迪米特法则这样有如此之多的表述方式，下面给出的也是众多的表述中较为有用的代表性的一种或者几种
    // 只与你直接的朋友通信
    // 不要跟陌生人说话
    // 每一个软件单位对其他的单位都是只有最少的知识，而且局限于那些与本单位密切的相关的软件单位
    //在上面的表述里面表述什么直接，陌生，和密切则被有意的模糊化了，以便在不同的环境中可以有不同的解释
    //
}
