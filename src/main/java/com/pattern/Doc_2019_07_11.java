package com.pattern;

public class Doc_2019_07_11 {
    // 在很多的情况下，缺乏经验的 java 设计师之所以选择继承关系描述两个类之间的关系，是因为对继承关系不理解不够造成的，而要正确地使用
    // 一般来说，对违反里氏替换原则的设计进行重构时，可以采用两个办法，一是加入一个抽象类超类，这一办法已经是本书的里氏替换原则 ，一章
    // 中讨论过，二是继承关系改写成合成聚合关系，这一点是本章讨论的重点
    // 区分 Has-A 与 is-A 是严格的分类学意义上的定义，意思是一个类是另一个类的一种而 Has-A 则不同，它表示某一个角色的具体一项责任
    // 导致错误的使用继承而不是合成聚合的一种觉的原则错误的把 Has-A 当作 is-A ，is-A 代表的是一个类的另一个特殊的种类，这是 Coad 条件的
    // 第一条，请考虑一下图所示的类图中所描述的一个例子，人被继承到雇员的，经理，和学生等子类 ，而实际上，雇员，经理，和学生分别描述的是一种
    // 角色，而人可以同时有几种不同的角色，比如一个人既然是经理，就必然是，这会使得一个人在成为雇员的身份后，就永远的为雇员，不能称为
    // 经理或者学生，而这个显然是不合理的
    // 当一个类是另一种角色的时候，不应当使用继承来描述这种关系
    // 里氏替换原则是继承利用的基石，如果任何使用 B 类型的地方都使用 S 类型，那么 S 类型才能称为 B 类型的子类型，而 B类型才能称为 S 类型的
    // 基类型
    // 只有当一个 S 在任何的情况下都是一种 B 的时候，才可以将 S 设计成 B 的子类 ，如果两个类的关系是 Has-A 关系而不是 IS-A 的关系
    // 这两个类一定违反里替换原则
    // 一个 Stack 不是一个 Vector,所以，Stack 不应当设置成为 Vector的子类 ，同样的，一个性质列不是一个 HashTable，在两种情况下
    // 使用聚合比使用继承关系更加合适
    // 由于 Properties 继承了 HashTable 的行为，因而当 p 是一个 Properties 类型的对象时，p.getProperties(key)与 p.get(key)
    // 就会给出不同的结果，前者来自于 Properties 的本身，因此会利用默认值，而后者来自于 Hashtable，因此不会利用默认值
    // 更加糟糕的是，由于 properties 是 hashTable 的子类 ，因此，客户端可以通过类型转换，直接使用超类型的行为，比如，Properties
    // 假定所有的键和值都是 String 类型的，如果不是，就导致运行崩溃，但是，客户端完全可以通过 Hashtable 提供的行为加入任意类型的
    // 键和值的，绕过 Properties 的接口，并导致 Properties 的内部矛盾和崩溃
    // 这样的来，properties 其实仅仅是一些hashTable 的属性，这是一个 hash-A 的关系，而不是一个 is-A 的关系
    // 迪米特法则，以叫做最少知识原则，一个对象应当对另一个对象有尽可能少的了解
    // 迪米特法则的各种表述
    // 没有任何的一个其他的 oo 设计原则像迪米特法则这样有如此之多的表述方式，下面给出的也是众多的表述中较为有用的代表性的一种或者几种
    // 只与你直接的朋友通信
    // 不要跟陌生人说话
    // 每一个软件单位对其他的单位都是只有最少的知识，而且局限于那些与本单位密切的相关的软件单位
    // 在上面的表述里面表述什么直接，陌生，和密切则被有意的模糊化了，以便在不同的环境中可以有不同的解释
    // 狭义的迪米特法则
    // 如果两个类不必彼此通信，那么这两个类就不应当发生直接相互作用，如果其中的一个类需要调用另一个类的某个方法的话，可以通过第三者
    // 转发这个调用
    // 朋友与陌生人若是朋友，组成朋友的朋友圈如下图所示
    // 相比较之下，某个人其实并不需要与陌生人直接的发生相互作用，但是朋友则更加需要也陌生人发生相互使用，这个时候，迪米特法则
    // 建义某人不要直接与陌生人发生相互作用，而是通过朋友发生相互使作用，
    // 这个时候，朋友实际上起了到了将某人对陌生人的调用而不知道陌生人，某人会认为他们调用的是这个方法的朋友的方法
    // 那么某人的朋友圈是怎样的确定的呢？
    // 朋友圈的确定
    // 以下的条件称为朋友的条件
    // 当前对象的本身
    // 以参量的形式传入到当前的对象的方法中的对象
    // 当前对象的实例变量直接引用的对象
    // 当前对象中的实例变量如果是一个聚集，那么聚集中的元素也是朋友
    // 当前对象所创建的对象
    // 任何的一个对象，如果满足以下的条件之一，就是当前对象的朋友，否则就是陌生人
    // 狭义的的迪米特法则会产生一个明显的缺点，会在系统造成大量的小方法，散落在系统的各个角落，这些方法仅仅是传递间接调用，因此与系统的
    // 商务逻辑无关，当设计师试图从一张图看出总体的架构时，这些小的方法会千万迷惑和困扰
    // 遵循类之间的迪米特法则会使一个系统局部设计简化，因为第一个局部都不会怪我和远距离的的对象有直接的关联，但是，这造成了一个系统的
    // 不同模式之间的通信效率降低，也会使系统不同模块之间不容易协调
    // 与依赖倒转原则互补使用
    // 指出，为了克隆狭义的迪米法则的缺点，可以使用依赖倒转原则，引入一个抽象的类型引用，抽象的陌生人对象使某人偏依赖于抽象的陌生人
    // 也就是将陌生人变成朋友
    // 某人现在是一个抽象的角色建立的朋友关系，这样做的好处就是朋友可以随时将具体的陌生人换掉，只要新的具体的陌生人，具有相同的抽象
    // 类型，那么某人就无法区分他们，这样允许陌生人的具体的实现可以独立于某人而变化 ，如下图所示
    // 狭义的迪米特法则 要求一个对象仅仅与其朋友发生关系，门面模式和调停者模式实际上就是迪米特的应用
    // 门面模式
    // 如果一个子系统内部的对象构成自己的朋友圈，而子系统的外部的对象都属于陌生人的话，而应当通过一个双方都认可的朋友，也就是门面的对象通信
    // 这就导致了门面模式
    // 门面模式创造出一个门面对象，将客户端所涉及的一个属于子系统的伙伴的数目减到最少，使得客户端与子系统的内部的对象的相互作用被
    // 门面对象所取代，显然，门面模式就是实现代码的重构以达到代码的重构以便达到迪米特法则要求的一个强大的有力的情况
    // 这个代码的和好处是很显然的，如果修改子系统的内部的话，不会直接影响到外部对象，而外部对象的修改不会导致子系统内部的修改，这样一来
    // 子系统就演化就相对绝缘了，关于门面模式，请参考门面模式的一章
    // 调停者模式
    // 这里一些对象形成一个中等规模，调停者模式
    // 这里一些对象形成一个中等规模的朋友圈，在圈内很多的对象都是排列组合般的交互作用，这时可以通过创建一个共有的一个朋友对象，然后大家
    // 通过这个朋友对象发生相互作用，而将相互使用的的作用省略掉，就导致了调停者模式
    // 调停者模式创建出一个调停对象，将系统中有有关对象所引用的其他的对象数目送至最少，使午一个对象与其同事的相互使用被这个对象与调停者对象
    // 的相互使用所取代，如下图所示，显然，调停者模式也是迪米特法则的一个具体的应用
    // 由此可见，迪米特法则是贯穿设计模式的核心设计思想，它可以通过设计模式体现出来，而理解这一思想，也有助于学习设计模式，将设计的思想应用
    // 到自己的设计中
    // 广义的迪米特法则
    // 其实，迪米特法则所谈论的，就是对象之间的的个处流量，流向以及信息影响的控制
    // 在软件系统中，一个模式设计得好不好的主要，最重要的标志，就是该模块在多大的程度上将自己的内部数据和其他的实现有关的系统比较隐藏起来
    // 一个好的设计模式可以将它所有的实现细节隐藏起来，彻底的将提供给我外界的API和自己的实现分隔开来，这样一来，模块秘模式之间就可以
    //通过彼此之间的api进行通信，而不会理会程序之间的细节部分，这一概念就是信息的隐藏，或者叫做封装，也就是大家所熟悉的软件设计的基本方法之一
    // 信息隐藏的非常重要的方法之一是，它们之间使得各个系统之间脱耦，从而允许他们可以被独立的开发，优化，使用，阅读以及修改，这种脱耦
    // 能够有效的加快开发的效率，因此可以同时开发各个模块，它可以维护过程变得容易，因此，所有的模块通俗易懂，特别是不必担心对他们的模块的
    // 影响
    // 虽然信息的隐藏并不会给系统本身带来什么性能上的提升，但是他可以使得性能的调整带来好处，如果某一个模块出现问题，设计人员可以根据这
    // 一个模块做本身进行优化，而不必担心影响到其他的模块
    // 信息的隐藏可以促进软件的利用，由于每一个模块者不依赖于其他的模块而存在，因此，每一个模块都可以独立的在其他的地方， 一个系统规模
    // 越大，信息的隐藏就是变得越重要
    // 迪米特法则的主要用意就是控制信息过载，在将迪米特法则运用到系统设计中，要注意以下的几点
    // 在类的划分的时候，应当创建有弱耦合的类，类之间的耦合越弱，就越有利于复用，一个处于弱耦合的类一旦被修改，不会对有关系的类造成波及
    // 在类的结构设计上，每一个类应当尽量降低成员的访问的权限，一个类的包装好的各自的private状态，这样一来，想要了解其中的一个类的意义时
    // 一个类不应当有public的属性，而应当提供取值和赋值方法让外界间接访问自己的属性
    // 在为类的设计上，只要有可能，一个类应当设计成不变类
    // 在对其他的类的引用上，一个对象对其他的对象引用应当降低到最低
    // 优先考虑将一个类设计成不可变类
    // java语言API提供了很多的不可变的类，比如：String,BigInterger,BigDecimal 等封装类都是不可变的，不变的类易于设计，实现和使用
    // 一个对象与外界的通信大体可以分成两种，一种是可变的这个对象的状态，另一种是不可变的对象的状态，如果一个对象的内部状态根本就是不可能
    // 改变的，那么它与外界的通信当然就大大的打折扣
    // 当涉及任何一个类的时候，都要首先考虑这个类的状态是否需要改变，即便一个类必须是可变类，在给它的属性设置赋值方法的时候，也要
    // 保持吝啬的态度，除非真需要，否则不要为一个属性设置赋值的方法
    // 尽量降低一个类的访问权限
    // 在满足一个类的访问权限
    // 在满足一个系统对这个系统需求的同时，应当尽量降低这个类的访问权限，对于顶级的类，来说，只有两个可能访问性等级
    // package-private :这个是默认的访问权限，如果一个类是package-private的，那么它就只能从当前的库中访问
    // public ,如果一个类是public 的，那么这个类从当前库和其他的库都可以访问
    // 一个具有package-private访问权限的好处是，一旦这个类发生修改，那么受到影响客户端改写都是在这个库内部，由于一个软件，
    // 相反，如果一个类被不恰当的设计成了public ,那么客户端程序就可能使用这个类，一旦这个类在一个新版本中被删除，就有可能造成一些客户程序
    // 停止运行的情况，
    // 因此，如果一个类可以设置成为package-private的，那么就不应当将它设置成public的
    // 谨慎使用Serilizable
    // 一个类如果实现了Serializable接口的话，客户端就可以将这个类的实例串行化，然后再并行化，由于串行化和并行化所涉及的类的内部结构
    // 如果这个类的内部的private结构，在一个版本中发生变化的话，那么客户端就会根据新的版本的结构试图将一个老版本的串行化的结果并行化
    // 这会导致失败
    // 为了防止这种情况的发生，软件提供商一旦将一个类设计成Serializable的，就不能再新的版本中修改这个类的内部结构，包括private的方法的
    // 和句段
    // 因此，除非必要，不要使用Serializable
    // 读者阅读配的原始模型模式，以及专题javaBean的化冷藏和解冻，一定要注意不要滥用串行化
    // 尽量降低成员的访问权限
    // 类的成员包括，属性，方法，嵌套灰，嵌套接口等，一个类的成员可以有四种不同的访问，
    // private ：这个成员可能从当前的顶级类的内部访问，
    // package-private : 这个成员方法可以当前的顶级类内部访问
    // protected :如果一个类成员是protected的，那么当前库中的任何的一个类都可以访问它，而且在任何类库的这个类的子类都可以访问它
    // public :此成员可以从任何地方被访问
    // 作为一条指导原则，在设计一个类的方法时，必须首先考虑将其设置成private的，只有在发现当前的库中还其他的方法需要调用这个方法时，才可以将
    // 这个类是否划分得当，是不是可以重新设计成两个或者多个类
    // 对于一个public类来说，将一个方法从package-private改成protected或者public意味着它的访问权限有巨大的变化，一旦一个方法被设置成了
    // protected这个方法就可以被们一地另一个库中的子类访问，如果设置成public，那么可以被任何的类访问，对于一个软件提供商，这就意味着会有客户程序使用
    // 这个方法，因此在所有的以后的程序中都要承诺不改变这个类的方法特征
    // 取代Struct
    // Java语言与C语言有很多的相信之处，很多的C程序员认为java没有指针的c语言，但是相比之下，C语言是一个面向数据的语言，
    // 而java言语是一个面向对象的语言
    // c语言中的struct结构以及enum结构 等，就是一个面向对象的数据结构，在java语言中没有一个发明一个类似的结构是非常的正确的，
    // 一个C的Struct仅仅是将几个数据段放到一个单一的数据结构中，而一个java类可以具备方法，从而将一个方法所涉及的数据向外界隐藏起来，一个类
    // 可以将数据封装到一个对象中，仅允许通过适当的方法访问这些数据，从而使得设计师可以在需要的时候改换这些数据表象 ，显然，C的struct不能提供
    // 这些好处
    // 广义的迪米特法则
    // 限制局域变量的有效范围
    // C语言要求所有的局域变量都在一程序块的开头声明，而java语言允许一个变量在任何的地方声明，即任何可以有语句的地方都可以声明变量，这样做的
    // 意义深远，是很多人想不到的地方
    // 在需要一个变量的时候才声明它，可以有效的限制局域变量的有效范围，一个变量如果仅仅在块的内部使用话，就应当将这个变量在程序块内部使用它的
    // 地方声明，而不是放到块的外部或者块的开关声明，这样做有两个好处
    // 程序员可以很容易的读懂程序
    // 试想如果所有的变量都是在开关声明变量的话，程序员必须反复对照使用变量的语句和变量的声明语句才能将变量的使用与声明对上号，很多的变量
    // 在声明的就不再使用，或者随着程序的一遍遍的修改，最后有很多的变量不再声明了，但是也没有人将声明语句删除
    // 如果局域变量都是仅仅在马上就要使用的时候才声明，就可以避免上面的情况了
    // 2.如果一个变量是在需要它的程序块的外部声明的，那么当这个块还没有被执行时，这个变量就已经被分配了内存了，而在这个程序块已经执行完毕后
    //  这个变量所占据的内存空间还没有被释放，这显然是不好的
    // 同样，如果局域变量都是马马虎虎就要使用的时候再声明，也可以避免这种情况发生
    //


}
