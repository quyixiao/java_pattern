package com.pattern.classloader;

public class LazySingleton  {
    private static LazySingleton m_instance = null;


    /***
     * 静态工厂方法
     * 返回lazySingleton类的唯一实例
     *
     * @return
     */
    public static LazySingleton getM_instance() {
       if(m_instance == null){
           m_instance = new LazySingleton();
       }
       return m_instance;
    }


    // 上面代码乍看起来是一个懒汉式单例类， 仔细一看，发现有一个公开的构造子，由于外界可以使用构造子创建出任意多个此类的实例，这违背了单例
    // 类只能有一个或有限个实例的特性，因此这个类不是完全的单例类，这种情况有时会出现，比如javax.swing.TimerQueue便是一例，请参见，观察
    // 模式与Swing定时器，一章
    // 造成这种情况出现的原因有多个可能
    // 初学者的错误，许多的初学者没有认识到构造子不能公开的，因此犯下这个错误，有些初学者java语言的学员甚至不知道一个java类的构造子是不能
    // 公开的，在这种情况下，设计师可能会通过自我约束，也就是说不去调用构造子的办法，将这种不完全单例类的使用中作为一个单例使用
    // 在这种情况下，一个简单的矫正办法，就是将公开的构造子改为私有的构造子
    // 当初出于考虑不周，将一个类设计成单例类，后来发现此类应当有一个或者多个实例，为了一个弥补错误，干脆将构造子改为公开的，以便在需要多个
    // 一个实例时，可以随时调用构造子创建新的实例
    // 要纠正这种情况较为困难，必须根据具体的情况做出决定，如果一个类在最初被设计成单例类，但是后来发现实际上此类应当有有限个多个实例，这时
    // 当考虑是否将单例类改为多例类
    // 设计师的java知识很好，而且也知道单例模式的正确使用方法，但是还是有意使用这种不完全的单例模式，因为他意在使用一改良的单例模式，这时候
    // 除去共有的构造子不符合单例模式的要求之外 ，这个类必须很好的单例模式
    // 默认的单例模式
    // 有些设计师将这种不完全的单例模式叫做里，一个类提供静态的方法，如同单例模式一样，同时又提供了一个公开的构造子，如同普通的类一样
    // 这样做的好处，这种模式允许客户端选择如何将类实例化，创建新的自己独有的实例，或者使用共享的实例
    // 这样一来，由于没有任何强制性的措施，客户端的选择不一定合理选择，其结果的设计往往不会花费时间如何提供最好的选择上，而是恰当将这种
    // 选择交给客户端程序员，这样必然导致不理想设计欠考虑的实现
    // 相关模式
    // 有一些模式可以使用单例模式，如抽象工厂模式可以使用单例模式，将具体的工厂类设计成单例模式，
    // 多例模式
    // 正如同本章所说的，单例模式的精神可以推广到多于一个实例的情况，这时候，类叫做多例类，这种模式叫做多例模式，单例类和多例类的类图所示
    // 关于多例模式，
    // 简单的工厂模式
    // 单例模式的使用的简单的工厂模式，又称为静态工厂模式，来提供自己的实例，在上面的ConfigManager的例子的代码中，静态工厂方法getInstance()
    // 就是静态的工厂方法，在java.awt.Toolkit类中，getDefaulToolkit() 方法就是静态工厂方法，简单的工厂模式简略类图如下图所示
    // 本章讨论单例模式的结构和实现方法
    // 单例械是一个看上去很简单的模式，很多的设计师最先学会往往是单例模式，然而，随着java系统日益变得得要和分散化，尽量不要使用有状态的
    // 单例模式可以提供很多得要的逻辑，而一个原始变量不能自己初始化，不可能，在可能，有继承关系，没有内部结构，因此，单例模式，有很多优越
    // 之处
    // 在java语言里没有内部结构，因此单例模式有很多优越之处
    // 在java言语并没有真正的全程变量，一个变量必须必须属于某一个类或者某一个实例，而复杂程序当中，一个静态变量的初始化发生，不可能有继
    // 继承关系，没有内部结构，因此单例模式有很多的优越之处
    // 在java语言里并没有真正的全程变量，一个变量必须属于某一个类或者某一个实例，而在复杂的程序当中，一个静态的变量的初始化，发生的哪一个
    // 里常常是一个不易确定的问题
    // 当然，使用全程，原始变量并没有错误，就好像选择，使用Fortran语言而非java语言编程并不是一种对错问题一样
    //



}
