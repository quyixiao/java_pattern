package com.pattern;

public class Doc {
    // 简单的工厂模式（创建模式）：最简单的模式，有助于引出工厂方法模式
    // 工厂方法模式（创建模式）：工厂方法模式在后面的许多模式都有应用，它在模式的讨论里里屡见不鲜，了解工厂方法模式是了解所有的模式的起点
    // 策略模式（行为模式）：策略模式在本书中讨论里频繁出现，早些理解策略模式有助于理解其他的模式
    // 装饰模式（结构模式）：装饰模式将是读者第一次接触到模式的高雅之外，学会区别装饰模式和策略模式，也将是读者第一次学会区别看上去相似而
    // 而实质不同的模式
    // 在学习了装饰装饰模式之后，感兴趣的读者可以进一步阅读装饰模式在 Java I/O 中应用，作为补充内容
    // 合成模式（结构模式）：合成模式在所有的场合都有可能出现，合成模式经常与迭代子模式，责任链模式，解释器模式，访问者模式联合使用，
    // 因此，好好的掌握合成模式有助于理解后面的有前模式
    // 迭代子模式（行为模式）：学习迭代模式可以加深读者对合成模式的理解，本书还提供了关于 java 语言的迭代子模式的支持的专题分析，供
    // 感兴趣的读者理解
    // 模版方法模式（行为模式）：学习模版方法模式可以加深读者对我不知道怎么办模式以及简单工厂模式的，工厂方法的模式理解，在迭代子模式里
    // 模版方法模式经常被用到
    //
    // 本书还提供了关于 java servlet 构造中的设计模式，主要模版方法模式的专题研究
    // 抽象工厂模式（创建模式）：抽象工厂模式是创建模式里的第三个模式，读者回到这个模式，可以复习一下工厂方法模式
    // 在这一章后面的附录中，本书还给出了 java 语言 API 中所使用的抽象工厂模式，供感兴趣的读者阅读
    // 建造模式（创建模式）：读者可以比较一下建造模式与抽象工厂模式的异同
    // 单例模式（创建模式）：单例模式经常用来实现抽象工厂模式的，在单例模式中相关模式一节中，对这一点还是很详尽的描述
    // 本书为单例模式提供了一个专题研究章节，用来加深读者对这个重要模式的具体系统的设计中的意义的了解
    // 多例模式（创建模式）：多例模式对单例模式的推广，在学习了单例模式之后，学习多例模式，可以对隐藏在二者背后的设计思想有更加深入的了解
    // 代理模式（结构模式）：读者在这里有机会学习到代理模式是怎样的控制外界对一个对象的引用，代理模式也把读者引导到下一个模式-适配器模式


    // 本书利用了三章的篇幅，分别以代理模式的基本实现，智能引用代理和虚引用代理等具体的种类详细的讲解也代理模式是怎样实现和应用到具体的问题里面去


    // 桥梁模式（结构模式）：现在读者可以比较桥梁模式与适配器模式的异同。
    // 缺省适配模式（结构模式）：缺省适配器模式是适配器模式中的一种特例，在学习了普通的适配器模式之后，再学习缺省的适配器模式可以更加
    // 好的理解和体会两者之间的关系和区别


    // 调停者模式（行为模式）：学习调停者模式是怎样在观察者模式里发挥作用的，实现 MVC 这一经典的设计的
    // 观察者模式（行为模式）：读者可以在学习中发现调停者模式是怎样在观察者模式里发挥作用的，实现 MVC 这一经典的设计的
    // 读者如果使用过 java 语言的事件处理机制的话，实际上就已经使用过观察者模式，只是没有察觉而已，本书除了使用一章的篇幅讲解观察者模式本身之外，还使用了三章的
    // 篇幅讲解观察者模式在几个著名的 Java API 中的应用
    //MVC 模式（架构模式）：MVC 模式包含合成模式，策略模式，观察者模式等，可是这些设计械模式的联合运用，
    // 责任链模式（行为模式）：学习责任链模式，读者可以比较责任链模式和观察者模式，调停者模式是怎样处理调用的
    // 在最后的一章中，本书还提供了一个专题章节，介绍使用责任在 java 语言中里对击鼓传花游戏的模似的内容
    // 备忘录模式（行为模式）:读者学习备忘录务工，并讨论了此模式是怎样实现 undo和 redo 的，并比较下面要介绍命令模式处理方法。
    // 命令模式（行为模式）: 命令模式可以有很多使用方法，其中之一与备忘录模式有关，因此，在备忘录模式后面介绍
    // 书本还对 Swing 库中命令的撤销做介绍
    // 原始模式模式（创建模式）：这可能是创建模式中最复杂的一个，原始模型模式经常与命令模式一起使用，这就是为什么在命令模式后面介绍的
    // 原因
    // 作为补充阅读，本书还对 JavaBean 的串行化和并行化做介绍
    // 状态模式（行为模式）：读者可以通过学习状态来理解一个对象改变状态的另一种方式
    // 本书利用状态模式对（聊斋志异）中的崂山道士的故事做了和分析
    // 访问者模式（行为模式）：访问者模式经常与合成模式，迭代子模式一起联合使用
    // 本书在介绍访问者模式之前，对双重分派的概念做了介绍
    // 享元模式（结构模式）：这是所有常见模式中最复杂的一个模式，这一模式的应用在下面的解释器模式介绍
    // 解释器模式（行为模式）：这是一个复杂的模式，学习这一模式最好的学习离远模式以及访问者模式之后.
    // 门面模式（结构模式）：这是最后一个学习的模式，在学习了解释器模式之后，门面模式就比较好学了，因为讲解门面模式的环境常常与讲解解释器
    // 模式的环境一样的



    // 现代科学和工程能够发展到今天，有赖于规则的制定，模式的研究也不例外，在讨论模式之前，必须对模式，这个词加以界定，以规范后面的讨论
    // 简而言之，人们在自己的环境中不断的发现问题，和寻找问题的解决方案的时候，发布有一些问题及其解决方案不断的换面孔重复出现 ，但是这些不同的
    // 面孔后面有着共同的本质，这些共同的本质就是模式

    // 那么，模式是不是在某种环境下面对某些问题的答案呢
    // 这不完全对，模式所描述的问题及问题的和问题的答案都就当是具有代表性的问题和问题的答案，所谓中具有代表性，就是说它以不同的形式重复
    // 出现，允许使用者举一反三，将它应用到不同的环境中去，为了与其他人交流，通常还要求给这个问题和问题的答案一个名字
    // 不知道读者会不会注意到，上面所使用的代表性，举一反三，等词汇，

    // 模式其实是非常适合中国人的思维方式，而不是西方人的思维方式，读者在阅读了本章之后，就会对这一点有更加深刻的认识



    // 对于一个软件系统而言，UML 语言具有以下的重要功能，可视化功能，说明功能，建造功能，和建文档功能

    // 结构型图
    // 如下所示，其中给出所有的 UML 结构图，当然所有的结构型里面，类图是最常用的
    // 类图：类图描述的一些类，包的静态结构和它们之间的静态关系
    // 对象图：对象图给出一个系统的对象的快照
    // 构件图：描述可以部署的软件构件，比如 jar文件，EJB 等，之间的静态关系，
    // 部署图：描述一个系统的拓扑结构
    // 显然：要描述一个设计模式的静态结构，使用类图是很合适的
    //


    // 行为型图
    // 案例图和时序图是最为常用的
    // 使用案例图：使用安全图描述一系列的角色和使用案例及它们之间的关系，可以用来对一个系统最基本的行为进行建模，
    // 活动图：描述不同过程之间的动态接触，活动图是使用案例图所描述的行为的具体化
    // 状态图：描述一系列对象的内部状态的变化和转移，注意一个类不能有两个不同的状态图
    // 时序图：时序图是一种互相作用的图，描述不同的对象之间信息传递的时序
    // 合作图：合作图是一种相互作用的图，描述发出信息，接收信息的一系列的对象组织结构
    // 显然 ，要描述一个设计模式的行为特性，使用状态图和时序图就很合适
    // 只要有意义，所有的类型的 UML 图都是可以混合在一起的，比如一个对象图可以与一个类图同时出现在一个结构图中，一个构件图中可以
    // 可以有类图的出现等，有的时候，一些 UML 建模工具软件不一定的对话这样做
    // 而在本书中，类图，状态图和序列图是最为常见的图
    // 应当指出的是，一个使用UML系统设计，往往是从使用的案例图开始的，而一个设计应当是以使用案例驱动的，
    //
    // 在上面的类图中可以看到，表示类的框架分成以下几层
    // 类名
    // 属性清单
    // 方法清单
    // 性质清单
    // 如果一个类有内部成员类，它的类图就会有五层，在类的类图加上中，除了类名层是不能省略，必须显示的以外，其他的几层都是可以在 UML 图中
    // 省略的
    // 第一层的类名，类名如果是正体字，表明类的具体的（Concrete，即可以实例化的类），变量名如是斜体字，表明类是的抽象的，显然在图中
    // 给出了一个具体的类，类名是不能省略的，必须显示的
    // 第二层是属性层，一个属性可以是 public,private 或 protected ，一个属性在左面如果有一个（+）加号，表示他是 public的，
    // 左边如果是减号（-）,表示他是 private，左面如果一个一井号（#），表示他是一个 protected 的
    // 第三层是方法层，一个方法的左面如果是一个加号（+）,表示它是 Public 的，左面如果有一个有一个减号（-）,表示它是 private，左面如果
    // 有一个井号（#）,表明它是 protected
    // 在 aPublicStaticMethod()方法下面有一道下划线，表明是一个静态的方法
    // 一个方法有几个要素，方法的名字，方法的变量与变量的数据类型，以及方法的数据类型，比如下面的方法中，方法的名字是 aPublicMethod
    // ,方法的变量有两个，分别是 param1,param2,其数据类型是 int 和 String,而方法的数据类型是 String,
    // public String aPublicMethod(int param1,String param2){
    //      return "return value="+param1+param2;
    // }
    // 第四层性质层，性质是由一个属性即由一个内部变量，一个赋值函数和一个取值函数组成，比如在上图的例子中 ,property1是一个性质，
    // 其结构可由代码清单看出
    // private String jobTitle;
    // public String getJobTitle(){
    //      return jobTitle;
    // }
    // public void setJobTitle(String jobTitle){
    //      this.jobTitle = jobTitle;
    // }
    // 描述接口的类图
    // 接口的类图与类的类图几乎是一样的，惟一的区别就是接口的名有"interface" 字样 ，右图所示的接口类图的一个例子，
    // 一个接口不会有性质，可以有方法的声明，public和 final 静态内部成员类，设计师可以选择只显示一个接口的各方法项示
    // 各属性项而不显示方法项
    // 对象图是一种特殊的类图，它显示的不是类而是类的实例，对象图在显示一小部分系统结构关系，特别是递归关系的时候，非常的有用
    // 类图中的关系
    // 在类与类之间，会有连线指明它们之间的关系，类和类，类和接口，接口与接口之间可以建立以下的几种关系：
    // 一般化关系，关联关系，聚合关系，合成关系，依赖关系，这几种关系都是静态的关系。
    // 一般化关系，表示类与类之间的继承关系，接口与接口之间的继承关系，或类对接口的实现关系，一般化关系是从子类指向父类的，或从
    // 实现接口的类指向被实现接口，与继承或实现方向相反，
    // 关联关系
    // 关联关系是类与类之间的联接，它使一个类知道另一个类的属性和方法，关联可以是双向的，也可以是单向的，
    // 聚合关系是关系关系的和种，是强大的关联关系，聚合是整体和个体之间的关系，例如汽车类与引擎类，轮胎类，他们之间是整体与个体之间的关系，
    // 也关联关系一样，聚合关系也是通过实例变量来实现的，但是，关联关系所涉及的两个类是处于同一层次上，而在聚合关系中，两个类处于
    // 不平等的层次上的，可以将之设置为关联关系，
    // 合成关系，合成关系是关联关系的一种，是比聚合关系强关系，它要求普通的聚合关系中的代表整体对象负责代表部分的对象的生命周期，
    // 合成关系是不能共享的，代表整体的对象需要负责保持对象的存活，
    // 在上面的类图中，显示了美猴王以及他的四肢和他的金箍棒之间的关系，可以看出，美猴王和他的金箍棒是合成关系，而美猴王和他的四肢是
    // 聚合关系，因为美猴王的四肢完全是由美猴王自己负责，并且不能共享
    //
    // 依赖也是类与类之间的连接，依赖总是单向的，依赖关系表示一个类依赖于另一个类的定义，一个人可以买车，和房子，person 类依赖于 Car 类
    // 和 House 类，如下图所示
    // 一般而言，依赖关系在 Java 语言中体现了局域变量，方法的参数，以及对静态方法的调用，换言之，一个类 A 的某一个局域变量的类型是
    // 另一个局域变量的类型是另一个类 B,那么类 A 就依赖于类 B,如果一个方法的参数是另一个类 B 的实例，那么这个方法所在的类 A 依赖于
    // 类 B,如果一个类 A 调用另一个类 B 的静态方法，那么这个类依赖于类 A
    // 如果类 B 出现在类 A 的实例变量中，那么类 B 的关系就超越了依赖关系，而变成了某一种关联关系。
    // 一般而言，每一个类图都应当有类，关联关系，基数，而关联关系的方向和关系中的角色是可选的，设计师可以在需要的时候加了强调。
    // 时序图有时又叫做序列图，活动序列图，作为交互图的一种，序列交互图按照时间顺序从上往下显示每个使用案例。
    // 在一个时序图中垂直的虚线叫做生命线，它代表一个对象存在的时间，每一个箭头都是一个调用，这个箭头从调用者对象连接到接收者
    // 每个箭头都是一个调用，这个箭头从调用者对象连接到接收者对象的生命线上的激活条上，每一个激活条代码调用所持续的时间
    // 状态图，又称做状态转换图，状态图的基本想法是定义一个具有有限个内部状态机器，因此状态图又称做是有限状态机，对象被外界
    // 事件激发，从而从一个状态转换成另一个状态，
    // 状态可以嵌套，一个状态可以有一些别的状态，大的状态叫做你父状态，或者超状态，小的状态叫做子状态，



}
