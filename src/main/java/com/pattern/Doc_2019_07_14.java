package com.pattern;

public class Doc_2019_07_14 {

    // 工厂方法模式
    // 工厂方法的类的创建模式，又叫做虚拟的构造子模式或者多态性工厂模式
    // 工厂方法模式的用意定义一个创建产品的对象工厂接口，将实际创建工作推迟到类中
    // 简单工厂模式的优缺点
    // 正如本书在简单工厂模式一章里介绍过的，工厂模式 有简单工厂模式，工厂方法模式和抽象工厂模式几种
    // 在简单的工厂模式中，一个工厂类处于对产品类的实例化的中心位置上，它知道每一个产品，它决定哪一个产品类就当被实例化，这个模式的优点
    // 是允许客户端相对于产品的创建过程，并且在系统引入新产品的时候无需修改客户端，也就是说，它的某种程度上支持开闭原则
    // 这个模式的缺点是对开闭原则支持不够，因为如果有新的产品加入到系统中去的时候，就需要修改工厂类，将必要的逻辑加入到工厂类中
    // 工厂方法的模式的引进
    // 本章要对讨论工厂方法模式的简单工厂模式的进一步抽象和推广，由于使用了多态性，工厂方法模式保持了简单的工厂模式的优点，而且克服了它的
    // 缺点
    // 首先，在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体的创建工作交给子类去做，这个核心的类则摇身一变，成为一个
    // 一个抽象工厂角色，仅仅负责给出具体的子类必须实现的接口，而不去接触哪一个产品的类应当被实例化的这种细节
    // 这种进一步抽象化的结果，使得这种工厂方法模式可以用来允许系统在不修改具体的工厂角色的情况下引进新的产品，这一个特点无疑使得工厂工具有
    // 超过简单工厂模式的优越性
    // 平行的等级结构
    // 在一个系统设计中，常常首先有产品的角色，然后有工厂的角色，在可以应用工厂方法的模式情况下，一般都会有一个产品的等级结构，由一个
    // 甚至是多个抽象产品和多个具体的产品组成，产品的等级结构如图所示，树图中阴影是树枝型节点
    // 在上面的产品等级结构中，出现了多于一个抽象产品类，以及多于两个层次，这其实是真实系统中常常出现的情况，当将工厂方法模式应用于这个
    // 系统升级中去的时候，常常彩的一个做法是按照产品的等级结构设计一个同结构的工厂等级结构，工厂的等级结构如下图所示
    // 树图中的阴影是树枝型节点
    // 然后由相应的工厂角色创建相应的产品角色，工厂方法模式的应用如下图所示，图中的虚线代表的是创建依赖关系
    // 工厂方法模式并没有限制产品的等级结构层数，一般书籍中都以两个层次为例，第一层是抽象产品层，第二层是具体的产品层，但是实际的系统中
    // 产品常有更加复杂的层次
    // 结构与角色
    // 为了说明工厂方法模式的结构，下面以一个最简单的情形为例，这个示意性类图如下图所示
    // 抽象工厂角色：担任这个角色的工厂方法模式的核心，它是应用程序无关的，任何的模式中创建的工厂方法必须实现这个接口，在上面的系统中，
    // 这个角色由于java接口的Creator扮演，在实际的系统中，这个角色是常常使用抽象的java类实现
    // 具体的工厂角色：担任这个角色的实现了抽象工厂接口的具体的java类，具体的工厂角色含有应用密切相关的逻辑，并且受到应用程序的调用以
    // 创建产品对象，在本系统中给出了两个这样的角色，也就是具体的java类ConcreteCreator1和ConcreateCreator2
    // 抽象产品角色，工厂方法械所创建的对象是超类型的，也就是产品对象共同父类或共同拥有的接口，在本系统中，这个角色由java接口的product
    // 扮演，在实际的系统中，这个角色也常常使用抽象的java类的实现
    // 具体的产品角色：这个角色实现了抽象产品角色所声明的接口，工厂方法模式所创建的每一个对象都是某个具体的产品角色实例
    // 在本系统中，这个角色由具体的java类ConcreateProduct1和ConCreateProduct2扮演，它们都实现了java接口的product
    // 最后， 为了说明这个系统的使用办法，特地的引进了一个客户端角色Client，这个角色的创建工厂对象，然后调用工厂对象的工厂方法创建了相应的和产品对象
    //

}
